<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Retro Moon Lander Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: black;
        }
        canvas {
            display: block;
            background: radial-gradient(circle at top, #000022, #000000);
        }
        #hud {
            position: absolute;
            top: 140px; /* Increased from 90px to prevent overlap */
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 20px;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            width: 200px; /* Added width to match mini-hud */
        }
        #hud div {
            margin-bottom: 8px;
        }
        .status-bars {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            justify-content: space-between;
        }
        .bar-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }
        #oxygenBarContainer, #fuelBarContainer {
            flex: 1;
            display: inline-block;
            vertical-align: middle;
            height: 20px;
            background-color: grey;
            border-radius: 5px;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: yellow;
            font-family: Arial, sans-serif;
            font-size: 36px;
            text-align: center;
            display: none;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255,255,255,0.7);
        }
        #restartButton {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            background-color: #5555FF;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #restartButton:hover {
            background-color: #7777FF;
        }
        /* Oxygen Bar Styles */
        #oxygenBar {
            width: 100%;
            height: 100%;
            background-color: #009dff; /* Default color */
            border-radius: 5px;
            transition: width 0.5s, background-color 0.5s; /* Smooth color transition */
            text-align: center;
            color: black;
            line-height: 20px; /* To vertically center the text */
            font-weight: bold;
        }
        /* Fuel Bar Styles */
        #fuelBar {
            width: 100%;
            height: 100%;
            background-color: #00c400; /* Green color for fuel */
            border-radius: 5px;
            transition: width 0.5s; /* Smooth width transition */
            text-align: center;
            color: black;
            line-height: 20px; /* To vertically center the text */
            font-weight: bold;
        }
        /* Loading Screen Styles */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-family: Arial, sans-serif;
        }
        #loadingText {
            font-size: 24px;
            margin-bottom: 20px;
        }
        #progressContainer {
            width: 400px;
            height: 30px;
            background-color: #333;
            border-radius: 15px;
            overflow: hidden;
        }
        #progressBar {
            width: 0%;
            height: 100%;
            background: linear-gradient(to right, #3498db, #2980b9);
            border-radius: 15px;
            transition: width 0.3s;
        }
        #progressText {
            margin-top: 10px;
            font-size: 16px;
        }
        
        /* Start Button Style */
        #startButton {
            display: none;
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 22px;
            font-weight: bold;
            background: linear-gradient(to bottom, #5c85d6, #3b5998);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            animation: pulse 1.5s infinite;
            transition: transform 0.2s, background 0.3s;
        }
        
        #startButton:hover {
            transform: scale(1.05);
            background: linear-gradient(to bottom, #6c95e6, #4b69a8);
        }
        
        #startButton:active {
            transform: scale(0.98);
        }
        
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(92, 133, 214, 0.7);
            }
            70% {
                box-shadow: 0 0 0 15px rgba(92, 133, 214, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(92, 133, 214, 0);
            }
        }

        /* Game Controls Guide */
        #controlsGuide {
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            max-width: 450px;
            text-align: left;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .key {
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            padding: 5px 10px;
            margin-right: 10px;
            font-weight: bold;
            min-width: 20px;
            text-align: center;
        }
        
        .control-description {
            flex: 1;
        }

        /* Mini HUD now in top left corner */
        #mini-hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 12px;
            border-radius: 15px;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            width: 200px;
        }
        
        .mini-bar-container {
            width: 100%;
            height: 14px;
            background-color: grey;
            border-radius: 7px;
            margin: 4px 0 10px 0;
            overflow: hidden;
        }
        
        #mini-oxygen-bar {
            width: 100%;
            height: 100%;
            background-color: #009dff;
            border-radius: 7px;
            transition: width 0.5s, background-color 0.5s;
        }
        
        #mini-fuel-bar {
            width: 100%;
            height: 100%;
            background-color: #00c400;
            border-radius: 7px;
            transition: width 0.5s;
        }
        
        .mini-label {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            margin-bottom: 2px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Mini HUD for oxygen and fuel -->
    <div id="mini-hud">
        <div class="mini-label">
            <span>OXYGEN</span>
            <span id="mini-oxygen-value">100%</span>
        </div>
        <div class="mini-bar-container">
            <div id="mini-oxygen-bar"></div>
        </div>
        
        <div class="mini-label">
            <span>FUEL</span>
            <span id="mini-fuel-value">100%</span>
        </div>
        <div class="mini-bar-container">
            <div id="mini-fuel-bar"></div>
        </div>
    </div>
    
    <!-- Simplified HUD without oxygen and fuel -->
    <div id="hud">
        Score: <span id="scoreValue">0</span><br>
        High Score: <span id="highScoreValue">0</span><br>
        Vertical Velocity: <span id="verticalVelocityValue">0</span><br>
        Horizontal Velocity: <span id="horizontalVelocityValue">0</span><br>
        Height: <span id="heightValue">0m</span>
    </div>

    <div id="message">
        <div id="gameMessage">Game Over!</div>
        <button id="restartButton">Restart</button>
    </div>
    <div id="loadingScreen">
        <div id="progressContainer">
            <div id="progressBar"></div>
        </div>
        <div id="progressText">0%</div>
        <button id="startButton">START MISSION</button>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        // Loading screen elements
        const loadingScreen = document.getElementById('loadingScreen');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const startButton = document.getElementById('startButton');
        
        // Audio loading tracking
        const soundFiles = {
            mainEngine: { src: 'main_engine.mp3', loaded: false },
            rotationEngine: { src: 'rotation_engine.mp3', loaded: false },
            breathing: { src: 'breathing.mp3', loaded: false },
            background: { src: 'background.mp3', loaded: false },
            crash: { src: 'crash_2.mp3', loaded: false },
            fuelUp: { src: 'fuel_up.mp3', loaded: false },
            pumpReset: { src: 'pump_reset.mp3', loaded: false },
            riser: { src: 'riser.mp3', loaded: false },
            gameOver: { src: 'game_over.mp3', loaded: false },
            vesselStartup: { src: 'vessel_startup.mp3', loaded: false } // Add vessel startup sound
        };
        
        let totalSounds = Object.keys(soundFiles).length;
        let loadedSounds = 0;
        let gameStarted = false;

        // Audio setup with loading handlers
        const mainEngineSound = new Audio();
        mainEngineSound.src = soundFiles.mainEngine.src;
        mainEngineSound.loop = true;
        
        const rotationEngineSound = new Audio();
        rotationEngineSound.src = soundFiles.rotationEngine.src;
        rotationEngineSound.loop = true;
        
        const breathingSound = new Audio();
        breathingSound.src = soundFiles.breathing.src;
        breathingSound.loop = false;
        
        const backgroundSound = new Audio();
        backgroundSound.src = soundFiles.background.src;
        backgroundSound.loop = true;
        backgroundSound.preload = "auto"; // Ensure preloading
        
        const crashSound = new Audio();
        crashSound.src = soundFiles.crash.src;

        const fuelUpSound = new Audio('fuel_up.mp3');
        fuelUpSound.volume = 0.7;
        fuelUpSound.preload = "auto"; // Ensure it's preloaded
        
        const pumpResetSound = new Audio('pump_reset.mp3');
        pumpResetSound.volume = 0.6;

        const riserSound = new Audio('riser.mp3');
        riserSound.volume = 0.7;
        riserSound.loop = false;
        
        const gameOverSound = new Audio('game_over.mp3');
        gameOverSound.loop = true;
        gameOverSound.volume = 0.5;

        const vesselStartupSound = new Audio('vessel_startup.mp3');
        vesselStartupSound.volume = 0.15;

        let riserSoundPlaying = false;
        let gameOverSoundPlaying = false;
        const LOW_OXYGEN_THRESHOLD = 5; // 4 seconds threshold
        
        let mainThrusterReleaseTimer = null;
        let mainThrusterStartTime = null; // Track when the main thruster was activated
        const MIN_THRUSTER_TIME = 2750; // Minimum time in ms the thruster must be active (2.75 seconds)

        // Game over messages
        const gameOverMessages = [
        "You're alone now. Only silence answers your calls.",
        "The stars look closer, but no one is coming.",
        "This was never meant to be your grave.",
        "No one knows you’re here. No one ever will.",
        "Out here, your screams are forever silent.",
        "The darkness sees you—but it doesn't care.",
        "Home is just a distant memory now.",
        "Forever trapped in the vastness between worlds.",
        "Space takes without remorse or mercy.",
        "How small you are, beneath an uncaring sky.",
        "No signal. No rescue. Just emptiness.",
        "Your footprints vanish. No one will follow.",
        "Space swallows all hope eventually.",
        "You left Earth, but you'll never return.",
        "Each breath takes you further from home.",
        "The universe never promised you'd survive.",
        "You were brave to venture this far—but now you're alone.",
        "Stars shine brighter as your vision fades.",
        "Silence reigns eternal beyond this point.",
        "You’re not the first to be lost out here.",
        "Even the stars look cold tonight.",
        "You call for help, but only echoes reply.",
        "Your journey ends here, lost in endless void.",
        "You reached for the stars—but the void took you."
        ];
    
        
        // Add loading event listeners
        mainEngineSound.addEventListener('canplaythrough', () => handleSoundLoaded('mainEngine'));
        rotationEngineSound.addEventListener('canplaythrough', () => handleSoundLoaded('rotationEngine'));
        breathingSound.addEventListener('canplaythrough', () => handleSoundLoaded('breathing'));
        backgroundSound.addEventListener('canplaythrough', () => handleSoundLoaded('background'));
        crashSound.addEventListener('canplaythrough', () => handleSoundLoaded('crash'));
        fuelUpSound.addEventListener('canplaythrough', () => handleSoundLoaded('fuelUp'));
        pumpResetSound.addEventListener('canplaythrough', () => handleSoundLoaded('pumpReset'));
        riserSound.addEventListener('canplaythrough', () => handleSoundLoaded('riser'));
        gameOverSound.addEventListener('canplaythrough', () => handleSoundLoaded('gameOver'));
        vesselStartupSound.addEventListener('canplaythrough', () => handleSoundLoaded('vesselStartup'));
        
        // Add event listener to start button
        startButton.addEventListener('click', startGame);

        // Handle sound loading
        function handleSoundLoaded(soundName) {
            if (!soundFiles[soundName].loaded) {
                soundFiles[soundName].loaded = true;
                loadedSounds++;
                
                // Update loading progress
                const progress = Math.floor((loadedSounds / totalSounds) * 100);
                progressBar.style.width = `${progress}%`;
                progressText.textContent = `${progress}%`;
                
                // Show start button and controls when all sounds are loaded
                if (loadedSounds === totalSounds) {
                    setTimeout(() => {
                        progressContainer.style.display = "none";
                        progressText.style.display = "none";
                        startButton.style.display = "block";
                        showControlsInstructions();
                    }, 500); // Small delay for visual feedback
                }
            }
        }
        
        // Set volume for sounds
        mainEngineSound.volume = 0.5;
        rotationEngineSound.volume = 0.40;
        backgroundSound.volume = 0.5;
        crashSound.volume = 0.40;
        breathingSound.volume = 1.00;

        let mainEngineSoundPlaying = false;
        let rotationEngineSoundPlaying = false;
        let breathingSoundPlaying = false;
        let translationEngineSoundPlaying = false; // New variable for A/D thrusters
        
        // Stars
        let stars = [];
        const NUM_STARS = 800;
        const STAR_COLOR = 'white';
        const STAR_MIN_RADIUS = 0.5;
        const STAR_MAX_RADIUS = 1.5;

        function generateStars() {
            stars = [];
            for (let i = 0; i < NUM_STARS; i++) {
                stars.push({
                    x: Math.random() * width * 2,
                    y: Math.random() * height * 2,
                    radius: Math.random() * (STAR_MAX_RADIUS - STAR_MIN_RADIUS) + STAR_MIN_RADIUS,
                    alpha: Math.random() * 0.5 + 0.5,
                    twinkleSpeed: Math.random() * 0.010 + 0.005,
                    twinkleDirection: Math.random() < 0.5 ? 1 : -1,
                    parallax: Math.random() * 0.5 + 0.5
                });
            }
        }
        generateStars();

        // Function to start the game after loading
        function startGame() {
            gameStarted = true;
            loadingScreen.style.display = 'none';
            
            // Make sure background music starts playing
            playBackgroundMusic();
            
            requestAnimationFrame(gameLoop);
        }

        // Function to ensure background music starts playing
        function playBackgroundMusic() {
            // Check if the sound is loaded and ready
            if (backgroundSound.readyState >= 2) { // HAVE_CURRENT_DATA or higher
                backgroundSound.currentTime = 0; // Reset to beginning
                
                // Use Promise to handle autoplay restrictions
                const playPromise = backgroundSound.play();
                
                // Handle potential promise rejection due to autoplay policies
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log("Autoplay prevented, adding click listener");
                        // Add a one-time click listener to start audio if autoplay is blocked
                        document.addEventListener('click', function startAudioOnClick() {
                            backgroundSound.play();
                            document.removeEventListener('click', startAudioOnClick);
                        });
                    });
                }
            } else {
                // If not ready, set up event listener to play when ready
                backgroundSound.addEventListener('canplaythrough', function playWhenReady() {
                    backgroundSound.play();
                    backgroundSound.removeEventListener('canplaythrough', playWhenReady);
                });
            }
        }

        // Function to fade audio volume smoothly
        function fadeAudioVolume(audioElement, startVolume, endVolume, durationMs) {
            const startTime = Date.now();
            const volumeChange = endVolume - startVolume;
            
            // Store original volume to restore if needed
            const originalVolume = audioElement.volume;
            audioElement.volume = startVolume;
            
            // Fade function that will be called repeatedly
            function updateVolume() {
                const currentTime = Date.now();
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / durationMs, 1);
                
                // Calculate new volume using linear interpolation
                const newVolume = startVolume + volumeChange * progress;
                audioElement.volume = newVolume;
                
                // Continue fading if not complete
                if (progress < 1) {
                    requestAnimationFrame(updateVolume);
                }
            }
            
            // Start the fade process
            requestAnimationFrame(updateVolume);
            
            // Return original volume for potential restoration
            return originalVolume;
        }

        // Game variables
        let oxygen = 70;
        let fuel = 1900;
        let score = 0;
        let gameOver = false;

        let highScore = localStorage.getItem('moonLanderHighScore') || 0;

        let gravity = 27;

        const lander = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            mass: 1,
            crashed: false,
            landed: false,
            explosionParticles: [],
            currentPlatform: null,
            speed: 0,
            controlsDisabled: false,
        };

        const keys = {};

        let terrain = [];
        let landingZones = [];
        let rocks = [];
        let craterMarks = [];
        let meteorites = [];

        let cameraX = 0;
        let cameraY = 0;

        let dustParticles = [];

        function generateLandscape() {
            terrain = [];
            landingZones = [];
            craterMarks = [];
            rocks = [];
            let points = [];
            let numPoints = 8000;
            let segmentWidth = 300;
            for (let i = 0; i <= numPoints; i++) {
                let x = i * segmentWidth;
                let y = height - Math.random() * 360 - 100;
                points.push({ x, y });
            }

            let platformSpacing = 200;
            let lastPlatformX = -platformSpacing;
            let platformsCreated = 0;

            for (let i = 2; i < points.length - 2; i++) {
                let x = points[i].x;
                if (Math.abs(x - lastPlatformX) < platformSpacing) continue;

                let y = Math.min(points[i].y, points[i + 1].y);
                let platformWidth = 50 + Math.random() * 100;

                let leftSlope = Math.abs(points[i].y - points[i - 1].y);
                let rightSlope = Math.abs(points[i + 2].y - points[i + 1].y);
                if (leftSlope > 100 || rightSlope > 100) continue;

                landingZones.push({
                    x,
                    y,
                    width: platformWidth,
                    landed: false,
                    points: Math.floor(200 - platformWidth),
                });

                points[i].y = y;
                points[i + 1].y = y;
                points[i + 1].x = x + platformWidth;

                lastPlatformX = x;
                platformsCreated++;
            }

            if (landingZones.length === 0) {
                let index = Math.floor(numPoints / 2);
                let x = points[index].x;
                let y = points[index].y;
                let platformWidth = 150;

                landingZones.push({
                    x,
                    y,
                    width: platformWidth,
                    landed: false,
                    points: Math.floor(200 - platformWidth),
                });
                points[index].y = y;
                points[index + 1].y = y;
                points[index + 1].x = x + platformWidth;
            }

            terrain = points;

            if (landingZones.length > 0) {
                let startingZone = landingZones[Math.floor(Math.random() * landingZones.length)];
                lander.x = startingZone.x + startingZone.width / 2;
                lander.y = startingZone.y - 200;
                cameraX = lander.x - width / 1.5;
                cameraY = lander.y - height / 2;
            } else {
                lander.x = width / 2;
                lander.y = height / 2;
                cameraX = lander.x - width / 2;
                cameraY = lander.y - height / 2;
            }

            for (let i = 0; i < 50; i++) {
                let craterX = Math.random() * terrain[terrain.length - 1].x;
                let craterY = getTerrainHeightAt(craterX);
                craterMarks.push({
                    x: craterX,
                    y: craterY,
                    radius: 10 + Math.random() * 15,
                });
            }

            for (let i = 0; i < 100; i++) {
                let rockX = Math.random() * terrain[terrain.length - 1].x;
                let rockY = getTerrainHeightAt(rockX);
                rocks.push({
                    x: rockX,
                    y: rockY,
                    size: 2 + Math.random() * 3,
                });
            }
        }

        generateLandscape();

        window.addEventListener('keydown', (e) => { 
            const key = e.key.toLowerCase();
            
            // If this is the first time the key is pressed (not a key repeat event)
            if (!keys[key]) {
                // Track when Arrow Up key is first pressed down
                if (key === 'arrowup') {
                    mainThrusterStartTime = Date.now();
                    
                    // Cancel any pending pump reset sound when thruster is reactivated
                    if (mainThrusterReleaseTimer !== null) {
                        clearTimeout(mainThrusterReleaseTimer);
                        mainThrusterReleaseTimer = null;
                    }
                }
            }
            
            keys[key] = true;
        });
        
        window.addEventListener('keyup', (e) => { 
            keys[e.key.toLowerCase()] = false; 
            
            // When arrow up key is released, check if we should play pump reset sound
            if (e.key === 'ArrowUp' && mainEngineSoundPlaying) {
                const thrusterDuration = Date.now() - mainThrusterStartTime;
                
                // Only schedule pump reset sound if thruster was active for minimum time
                if (thrusterDuration >= MIN_THRUSTER_TIME) {
                    // Clear any existing timer
                    if (mainThrusterReleaseTimer !== null) {
                        clearTimeout(mainThrusterReleaseTimer);
                    }
                    
                    // Set new timer for 1.5 second delay
                    mainThrusterReleaseTimer = setTimeout(() => {
                        pumpResetSound.currentTime = 0;
                        pumpResetSound.play();
                        mainThrusterReleaseTimer = null;
                    }, 1500);
                }
            }
        });
        window.addEventListener('resize', onResize);
        document.getElementById('restartButton').addEventListener('click', restartGame);

        function onResize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            generateStars();
            generateLandscape();
            updateHUD();
        }

        function getTerrainHeightAt(x) {
            for (let i = 0; i < terrain.length - 1; i++) {
                let p1 = terrain[i];
                let p2 = terrain[i + 1];
                if (x >= p1.x && x <= p2.x) {
                    let m = (p2.y - p1.y) / (p2.x - p1.x);
                    let b = p1.y - m * p1.x;
                    let groundY = m * x + b;
                    return groundY;
                }
            }
            return height;
        }

        function update(deltaTime) {
            if (gameOver) return;

            let deltaTimeSec = deltaTime / 1000;

            if (lander.crashed) {
                for (let particle of lander.explosionParticles) {
                    particle.x += particle.vx * deltaTimeSec;
                    particle.y += particle.vy * deltaTimeSec;
                    particle.vy += gravity * deltaTimeSec;
                    particle.alpha -= deltaTimeSec;
                }
                lander.explosionParticles = lander.explosionParticles.filter(p => p.alpha > 0);

                if (lander.explosionParticles.length === 0) {
                    endGame('Crash! \n Game Over. \n Final Score: ' + score);
                }
                return;
            }

            oxygen -= deltaTimeSec;
            if (oxygen <= 0) {
                oxygen = 0;
                lander.controlsDisabled = true;
                if (breathingSoundPlaying) {
                    breathingSound.pause();
                    breathingSound.currentTime = 0;
                    breathingSoundPlaying = false;
                }
                if (lander.landed && !lander.crashed) {
                    endGame('Out of Oxygen! Game Over. Final Score: ' + score);
                }
            }

            // Handle low oxygen alarm (riser sound)
            if (oxygen <= LOW_OXYGEN_THRESHOLD && oxygen > 0) {
                if (!riserSoundPlaying) {
                    riserSound.currentTime = 0;
                    riserSound.play();
                    riserSoundPlaying = true;
                }
            } else {
                if (riserSoundPlaying) {
                    riserSound.pause();
                    riserSound.currentTime = 0;
                    riserSoundPlaying = false;
                }
            }

            if (oxygen <= 10 && oxygen > 0) {
                if (!breathingSoundPlaying) {
                    breathingSound.play();
                    breathingSoundPlaying = true;
                }
            } else {
                if (breathingSoundPlaying) {
                    breathingSound.pause();
                    breathingSound.currentTime = 0;
                    breathingSoundPlaying = false;
                }
            }

            if (!lander.controlsDisabled && fuel > 0) {
                if (keys['arrowup']) {
                    let thrust = 65;
                    let adjustedThrust = thrust * (1 + (1900 - fuel) / 1900);
                    lander.vx += adjustedThrust * Math.sin(lander.angle) * deltaTimeSec;
                    lander.vy -= adjustedThrust * Math.cos(lander.angle) * deltaTimeSec;
                    fuel -= 0.48;

                    emitDustParticles(deltaTimeSec);
                }
                if (keys['arrowleft']) {
                    lander.angularVelocity -= 90 * Math.PI / 180 * deltaTimeSec;
                    fuel -= 0.13;
                }
                if (keys['arrowright']) {
                    lander.angularVelocity += 90 * Math.PI / 180 * deltaTimeSec;
                    fuel -= 0.13;
                }
                if (keys['d']) {
                    let thrust = 27;
                    lander.vx += thrust * Math.sin(lander.angle - Math.PI / 2) * deltaTimeSec;
                    lander.vy -= thrust * Math.cos(lander.angle - Math.PI / 2) * deltaTimeSec;
                    fuel -= 0.13;
                }
                if (keys['a']) {
                    let thrust = 27;
                    lander.vx += thrust * Math.sin(lander.angle + Math.PI / 2) * deltaTimeSec;
                    lander.vy -= thrust * Math.cos(lander.angle + Math.PI / 2) * deltaTimeSec;
                    fuel -= 0.13;
                }
            }

            if (!lander.controlsDisabled && fuel > 0 && !lander.crashed) {
                if (keys['arrowup']) {
                    if (!mainEngineSoundPlaying) {
                        mainEngineSound.play();
                        mainEngineSoundPlaying = true;
                    }
                } else {
                    if (mainEngineSoundPlaying) {
                        mainEngineSound.pause();
                        mainEngineSound.currentTime = 0;
                        mainEngineSoundPlaying = false;
                    }
                }
            } else {
                if (mainEngineSoundPlaying) {
                    mainEngineSound.pause();
                    mainEngineSound.currentTime = 0;
                    mainEngineSoundPlaying = false;
                }
            }

            if (!lander.controlsDisabled && fuel > 0 && !lander.crashed) {
                if (keys['a'] || keys['d']) {
                    if (!translationEngineSoundPlaying) {
                        rotationEngineSound.play();
                        translationEngineSoundPlaying = true;
                    }
                } else {
                    if (translationEngineSoundPlaying) {
                        if (!keys['arrowleft'] && !keys['arrowright']) {
                            rotationEngineSound.pause();
                            rotationEngineSound.currentTime = 0;
                        }
                        translationEngineSoundPlaying = false;
                    }
                }
            } else {
                if (translationEngineSoundPlaying) {
                    if (!rotationEngineSoundPlaying) {
                        rotationEngineSound.pause();
                        rotationEngineSound.currentTime = 0;
                    }
                    translationEngineSoundPlaying = false;
                }
            }

            if (!lander.controlsDisabled && fuel > 0 && !lander.crashed) {
                if (keys['arrowleft'] || keys['arrowright']) {
                    if (!rotationEngineSoundPlaying) {
                        if (!translationEngineSoundPlaying) {
                            rotationEngineSound.play();
                        }
                        rotationEngineSoundPlaying = true;
                    }
                } else {
                    if (rotationEngineSoundPlaying) {
                        if (!translationEngineSoundPlaying) {
                            rotationEngineSound.pause();
                            rotationEngineSound.currentTime = 0;
                        }
                        rotationEngineSoundPlaying = false;
                    }
                }
            } else {
                if (rotationEngineSoundPlaying) {
                    if (!translationEngineSoundPlaying) {
                        rotationEngineSound.pause();
                        rotationEngineSound.currentTime = 0;
                    }
                    rotationEngineSoundPlaying = false;
                }
            }

            lander.vy += gravity * deltaTimeSec;
            lander.x += lander.vx * deltaTimeSec;
            lander.y += lander.vy * deltaTimeSec;
            lander.angle += lander.angularVelocity * deltaTimeSec;

            if (lander.angle > Math.PI) lander.angle -= 2 * Math.PI;
            if (lander.angle < -Math.PI) lander.angle += 2 * Math.PI;

            lander.speed = Math.sqrt(lander.vx * lander.vx + lander.vy * lander.vy);

            let leftBoundary = cameraX + width / 3;
            let rightBoundary = cameraX + (2 * width) / 3;

            if (lander.x < leftBoundary) {
                cameraX -= (leftBoundary - lander.x) * 0.1;
            } else if (lander.x > rightBoundary) {
                cameraX += (lander.x - rightBoundary) * 0.1;
            }

            let topBoundary = cameraY + height * 0.2;
            let bottomBoundary = cameraY + height * 0.6;

            if (lander.y < topBoundary) {
                cameraY -= (topBoundary - lander.y) * 0.1;
            } else if (lander.y > bottomBoundary) {
                cameraY += (lander.y - bottomBoundary) * 0.1;
            }

            let landerBottom = { x: lander.x, y: lander.y + 20 };
            for (let i = 0; i < terrain.length - 1; i++) {
                let p1 = terrain[i];
                let p2 = terrain[i + 1];
                if (landerBottom.x >= p1.x && landerBottom.x <= p2.x) {
                    let m = (p2.y - p1.y) / (p2.x - p1.x);
                    let b = p1.y - m * p1.x;
                    let groundY = m * landerBottom.x + b;
                    if (landerBottom.y >= groundY) {
                        lander.y = groundY - 20;

                        let safeLandingSpeed = 57;
                        let verticalSpeed = lander.vy;

                        lander.vx = 0;
                        lander.vy = 0;
                        lander.angularVelocity = 0;

                        if (verticalSpeed > safeLandingSpeed || Math.abs(lander.angle) > Math.PI / 6) {
                            crash();
                        } else {
                            let landedOnPlatform = false;
                            for (let zone of landingZones) {
                                if (lander.x >= zone.x && lander.x <= zone.x + zone.width) {
                                    landedOnPlatform = true;
                                    if (!zone.landed) {
                                        successfulLanding(zone);
                                        zone.landed = true;
                                        lander.currentPlatform = zone;
                                    } else {
                                        lander.currentPlatform = zone;
                                    }
                                    break;
                                }
                            }
                            if (!landedOnPlatform) {
                                crash();
                            } else {
                                lander.landed = true;
                                if (oxygen <= 0) {
                                    endGame('Out of Oxygen! Game Over. Final Score: ' + score);
                                }
                            }
                        }
                        break;
                    }
                }
            }

            if (lander.landed && lander.y + 20 < lander.currentPlatform.y - 1) {
                lander.landed = false;
                lander.currentPlatform = null;
            }

            updateMeteorites(deltaTimeSec);
            updateDustParticles(deltaTimeSec);
            updateHUD();
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            ctx.save();
            for (let star of stars) {
                star.x -= lander.vx * 0.00010 * star.parallax;
                star.y -= lander.vy * 0.00010 * star.parallax;

                star.alpha += star.twinkleSpeed * star.twinkleDirection;
                if (star.alpha >= 1.0) {
                    star.alpha = 1.0;
                    star.twinkleDirection = -1;
                } else if (star.alpha <= 0.5) {
                    star.alpha = 0.5;
                    star.twinkleDirection = 1;
                }

                ctx.globalAlpha = star.alpha;
                ctx.fillStyle = STAR_COLOR;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
            ctx.restore();

            ctx.save();
            ctx.translate(-cameraX, -cameraY);

            let terrainGradient = ctx.createLinearGradient(0, cameraY, 0, cameraY + height);
            terrainGradient.addColorStop(0, '#7B7B7B');
            terrainGradient.addColorStop(1, '#4B4B4B');

            ctx.fillStyle = terrainGradient;
            ctx.beginPath();
            ctx.moveTo(terrain[0].x, cameraY + height);
            for (let point of terrain) {
                ctx.lineTo(point.x, point.y);
            }
            ctx.lineTo(terrain[terrain.length - 1].x, cameraY + height);
            ctx.closePath();
            ctx.fill();

            for (let crater of craterMarks) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(crater.x, crater.y, crater.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = '#3D3D3D';
            for (let rock of rocks) {
                ctx.beginPath();
                ctx.arc(rock.x, rock.y, rock.size, 0, Math.PI * 2);
                ctx.fill();
            }

            for (let zone of landingZones) {
                ctx.fillStyle = zone.landed ? '#555555' : 'yellow';
                ctx.fillRect(zone.x, zone.y - 5, zone.width, 5);
            }

            for (let meteor of meteorites) {
                if (!meteor.exploded) {
                    ctx.save();
                    ctx.translate(meteor.x, meteor.y);
                    ctx.fillStyle = 'gray';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            for (let meteor of meteorites) {
                if (meteor.exploded && meteor.explosionParticles) {
                    for (let particle of meteor.explosionParticles) {
                        ctx.save();
                        ctx.globalAlpha = particle.alpha;
                        ctx.fillStyle = 'orange';
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
            }

            for (let dust of dustParticles) {
                ctx.save();
                ctx.globalAlpha = dust.alpha;
                ctx.fillStyle = 'rgba(128,128,128, 0.6)';
                ctx.beginPath();
                ctx.arc(dust.x, dust.y, dust.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            if (lander.crashed) {
                for (let particle of lander.explosionParticles) {
                    ctx.save();
                    ctx.globalAlpha = particle.alpha;
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            } else {
                ctx.save();
                ctx.translate(lander.x, lander.y);
                ctx.rotate(lander.angle);

                ctx.fillStyle = '#CCCCCC';
                ctx.beginPath();
                ctx.moveTo(-15, -20);
                ctx.lineTo(15, -20);
                ctx.lineTo(15, 10);
                ctx.lineTo(-15, 10);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#999999';
                ctx.stroke();

                ctx.fillStyle = '#5555FF';
                ctx.beginPath();
                ctx.arc(0, -10, 7, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.strokeStyle = '#888888';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-15, 10);
                ctx.lineTo(-25, 25);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(15, 10);
                ctx.lineTo(25, 25);
                ctx.stroke();

                // Draw main thruster flame behind the lander
                if (keys['arrowup'] && fuel > 0 && !lander.controlsDisabled) {
                    // Save current state before drawing flame
                    ctx.save();
                    
                    // Move flame behind the lander by using globalCompositeOperation
                    ctx.globalCompositeOperation = 'destination-over';
                    
                    // Give the flame some variability
                    let flameHeight = 30 + Math.random() * 7; 
                    let flameWidth = 7 + Math.random() * 1;
                    
                    // Position flame higher up (reduce the 10 to a smaller value)
                    let flameStartY = 1; // Start flame higher up behind the vessel
                     
                    // We'll position the gradient roughly in the vertical center of the flame
                    let centerY = flameStartY + flameHeight / 2; 

                    // Create a radial gradient that starts bright in the center and goes to red on the edges
                    let gradient = ctx.createRadialGradient(
                        0, centerY, 0,         // inner circle (x, y, radius)
                        0, centerY, flameWidth * 1.2 // outer circle (x, y, radius)
                    );
                    // A bright core that transitions to yellow, orange, and finally red
                    gradient.addColorStop(0.0, 'white');
                    gradient.addColorStop(0.25, 'yellow');
                    gradient.addColorStop(0.80, 'orange');
                    gradient.addColorStop(1.0, 'orange');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    // Start at the top (behind the lander)
                    ctx.moveTo(0, flameStartY);

                    // Left side curve: top -> mid -> bottom
                    ctx.bezierCurveTo(
                        -flameWidth, flameStartY + flameHeight * 0.3,
                        -flameWidth, flameStartY + flameHeight * 0.7,
                        0,          flameStartY + flameHeight
                    );

                    // Right side curve: bottom -> mid -> top
                    ctx.bezierCurveTo(
                        flameWidth, flameStartY + flameHeight * 0.7,
                        flameWidth, flameStartY + flameHeight * 0.3,
                        0,         flameStartY
                    );
                    ctx.closePath();
                    ctx.fill();
                    
                    // Restore drawing state
                    ctx.restore();
                }

                if (keys['a'] && fuel > 0 && !lander.controlsDisabled) {
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.moveTo(-15, -2.5);
                    ctx.lineTo(-25 - Math.random() * 5, 0);
                    ctx.lineTo(-15, 2.5);
                    ctx.closePath();
                    ctx.fill();
                }

                if (keys['d'] && fuel > 0 && !lander.controlsDisabled) {
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.moveTo(15, -2.5);
                    ctx.lineTo(25 - Math.random() * 5, 0);
                    ctx.lineTo(15, 2.5);
                    ctx.closePath();
                    ctx.fill();
                }

                if (keys['arrowright'] && fuel > 0 && !lander.controlsDisabled) {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(-15, -16.5);
                    ctx.lineTo(-25 - Math.random() * 5, -10);
                    ctx.lineTo(-15, -12.5);
                    ctx.closePath();
                    ctx.fill();
                }

                if (keys['arrowleft'] && fuel > 0 && !lander.controlsDisabled) {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(15, -16.5);
                    ctx.lineTo(25 - Math.random() * 5, -10);
                    ctx.lineTo(15, -12.5);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }

            ctx.restore();

            updateHUD();
        }

        let lastTime = 0;
        let hudUpdateCounter = 0;  // Add counter for throttling HUD updates
        let hudUpdateFrequency = 5;  // Only update every 5 frames
        let lastHeightDisplay = 0;
        let lastVelocityDisplay = 0;
        let lastHorizontalVelocityDisplay = 0; // Add variable for horizontal velocity

        function updateHUD() {
            const groundY = getTerrainHeightAt(lander.x);
            const heightAboveTerrain = groundY - (lander.y + 20);

            const fuelPercentage = Math.max(0, Math.min((fuel / 1900) * 100, 100));
            document.getElementById('mini-fuel-value').textContent = Math.floor(fuelPercentage) + '%';
            const miniFuelBar = document.getElementById('mini-fuel-bar');
            miniFuelBar.style.width = fuelPercentage + '%';

            const oxygenPercentage = Math.max(0, Math.min((oxygen / 70) * 100, 100));
            document.getElementById('mini-oxygen-value').textContent = Math.floor(oxygenPercentage) + '%';
            const miniOxygenBar = document.getElementById('mini-oxygen-bar');
            miniOxygenBar.style.width = oxygenPercentage + '%';

            if (oxygen > 10) {
                miniOxygenBar.style.backgroundColor = "#009dff";
            } else if (oxygen > 5) {
                miniOxygenBar.style.backgroundColor = 'orange';
            } else {
                miniOxygenBar.style.backgroundColor = 'red';
            }

            if (fuelPercentage > 50) {
                miniFuelBar.style.backgroundColor = '#00c400';
            } else if (fuelPercentage > 20) {
                miniFuelBar.style.backgroundColor = 'yellow';
            } else {
                miniFuelBar.style.backgroundColor = 'red';
            }

            document.getElementById('scoreValue').textContent = score;
            document.getElementById('highScoreValue').textContent = highScore;
            
            // Throttle height and velocity updates to reduce flickering
            hudUpdateCounter++;
            if (hudUpdateCounter >= hudUpdateFrequency) {
                hudUpdateCounter = 0;
                
                // Update vertical velocity (absolute value, no decimals)
                const absoluteVelocity = Math.floor(Math.abs(lander.vy));
                lastVelocityDisplay = absoluteVelocity;
                document.getElementById('verticalVelocityValue').textContent = absoluteVelocity;
                
                // Update horizontal velocity (absolute value, no decimals)
                const absoluteHorizontalVelocity = Math.floor(Math.abs(lander.vx));
                lastHorizontalVelocityDisplay = absoluteHorizontalVelocity;
                document.getElementById('horizontalVelocityValue').textContent = absoluteHorizontalVelocity;
                
                // Update height (divided by 10, with "m" suffix)
                const heightInMeters = Math.floor(heightAboveTerrain / 10);
                lastHeightDisplay = heightInMeters;
                document.getElementById('heightValue').textContent = heightInMeters + "m";
            } else {
                // Use last calculated values to maintain display
                document.getElementById('verticalVelocityValue').textContent = lastVelocityDisplay;
                document.getElementById('horizontalVelocityValue').textContent = lastHorizontalVelocityDisplay;
                document.getElementById('heightValue').textContent = lastHeightDisplay + "m";
            }
        }

        function crash() {
            lander.crashed = true;
            lander.landed = false;

            if (mainEngineSoundPlaying) {
                mainEngineSound.pause();
                mainEngineSound.currentTime = 0;
                mainEngineSoundPlaying = false;
            }
            if (rotationEngineSoundPlaying || translationEngineSoundPlaying) {
                rotationEngineSound.pause();
                rotationEngineSound.currentTime = 0;
                rotationEngineSoundPlaying = false;
                translationEngineSoundPlaying = false;
            }
            if (breathingSoundPlaying) {
                breathingSound.pause();
                breathingSound.currentTime = 0;
                breathingSoundPlaying = false;
            }
            if (riserSoundPlaying) {
                riserSound.pause();
                riserSound.currentTime = 0;
                riserSoundPlaying = false;
            }

            crashSound.play();

            lander.explosionParticles = [];
            let numParticles = 30;
            for (let i = 0; i < numParticles; i++) {
                lander.explosionParticles.push({
                    x: lander.x,
                    y: lander.y,
                    vx: (Math.random() - 0.5) * 200,
                    vy: (Math.random() - 0.5) * 200,
                    alpha: 1.0,
                });
            }
        }

        function successfulLanding(platform) {
            if (!platform.landed) {
                score += platform.points;
                fuel += 340;
                oxygen += 17.5;
                fuel = Math.min(fuel, 1900);
                oxygen = Math.min(oxygen, 70);
                
                // Optimize sound playback for minimal delay
                try {
                    fuelUpSound.pause(); // Stop any existing playback
                    fuelUpSound.currentTime = 0; // Reset to beginning
                    const playPromise = fuelUpSound.play();
                    
                    // Handle promise in case of autoplay restrictions
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.log("Could not play fuel up sound:", error);
                        });
                    }
                } catch (e) {
                    console.log("Error playing fuel up sound:", e);
                }
            }
            lander.vx = 0;
            lander.vy = 0;
            lander.angularVelocity = 0;
            lander.angle = 0;

            lander.landed = true;

            score += 50;
        }

        function endGame(message) {
            gameOver = true;

            // Fade down background music to 25% over 3 seconds
            if (backgroundSound.volume > 0) {
            fadeAudioVolume(backgroundSound, backgroundSound.volume, 0.125, 1500);
            }
            
            // Play game over sound
            if (!gameOverSoundPlaying) {
            gameOverSound.currentTime = 0;
            gameOverSound.play().catch(err => console.log("Could not play game over sound:", err));
            gameOverSoundPlaying = true;
            }

            // Stop all other active sounds
            if (mainEngineSoundPlaying) {
            mainEngineSound.pause();
            mainEngineSound.currentTime = 0;
            mainEngineSoundPlaying = false;
            }
            if (rotationEngineSoundPlaying || translationEngineSoundPlaying) {
            rotationEngineSound.pause();
            rotationEngineSound.currentTime = 0;
            rotationEngineSoundPlaying = false;
            translationEngineSoundPlaying = false;
            }
            if (breathingSoundPlaying) {
            breathingSound.pause();
            breathingSound.currentTime = 0;
            breathingSoundPlaying = false;
            }
            if (riserSoundPlaying) {
            riserSound.pause();
            riserSound.currentTime = 0;
            riserSoundPlaying = false;
            }

            // Update high score if needed
            if (score > highScore) {
            highScore = score;
            localStorage.setItem('moonLanderHighScore', highScore);
            document.getElementById('highScoreValue').textContent = highScore;
            }

            // Get random message from gameOverMessages array
            const randomMessage = gameOverMessages[Math.floor(Math.random() * gameOverMessages.length)];
            
            // Display game over message
            const messageDiv = document.getElementById('message');
            const gameMessage = document.getElementById('gameMessage');
            
            // Create and add pulsing shadow animation
            const style = document.createElement('style');
            style.textContent = `
            @keyframes pulseShadow {
                0% { box-shadow: 0 0 30px rgba(255, 0, 0, 0.3), 0 0 60px rgba(255, 0, 0, 0.2); }
                50% { box-shadow: 0 0 40px rgba(255, 0, 0, 0.3), 0 0 80px rgba(255, 0, 0, 0.3); }
                100% { box-shadow: 0 0 30px rgba(255, 0, 0, 0.3), 0 0 60px rgba(255, 0, 0, 0.2); }
            }
            `;
            document.head.appendChild(style);
            
            // Apply enhanced styling to message box with animation
            messageDiv.style.background = 'rgba(0, 0, 0, 0.85)';
            messageDiv.style.borderRadius = '15px';
            messageDiv.style.animation = 'pulseShadow 4s ease-in-out infinite';
            messageDiv.style.border = '1px solid rgba(255, 100, 100, 0.5)';
            messageDiv.style.padding = '40px';
            messageDiv.style.maxWidth = '500px';
            
            // Set message content
            gameMessage.innerHTML = `<div style="font-size: 32px; margin-bottom: 20px; color: #ff7777;">MISSION FAILED</div>
                        <div style="font-size: 20px; margin-bottom: 30px;">${randomMessage}</div>
                        <div style="color: #aaaaaa; margin-top: 20px;">Final Score: ${score}</div>`;
            
            messageDiv.style.display = 'block';
        }

        function restartGame() {
            oxygen = 60;
            fuel = 1900;
            score = 0;
            gameOver = false;
            lander.crashed = false;
            lander.landed = false;
            lander.controlsDisabled = false;
            generateLandscape();
            generateStars();
            meteorites = [];
            craterMarks = [];
            rocks = [];
            dustParticles = [];
            document.getElementById('message').style.display = 'none';
            lander.vx = 0;
            lander.vy = 0;
            lander.angle = 0;
            lander.angularVelocity = 0;
            lander.explosionParticles = [];
            lander.currentPlatform = null;

            mainEngineSound.pause();
            mainEngineSound.currentTime = 0;
            mainEngineSoundPlaying = false;
            
            mainThrusterStartTime = null;
            if (mainThrusterReleaseTimer !== null) {
                clearTimeout(mainThrusterReleaseTimer);
                mainThrusterReleaseTimer = null;
            }

            rotationEngineSoundPlaying = false;
            rotationEngineSound.pause();
            rotationEngineSound.currentTime = 0;

            crashSound.pause();
            crashSound.currentTime = 0;

            breathingSound.pause();
            breathingSound.currentTime = 0;
            breathingSoundPlaying = false;

            translationEngineSoundPlaying = false;

            if (riserSoundPlaying) {
                riserSound.pause();
                riserSound.currentTime = 0;
                riserSoundPlaying = false;
            }

            // Stop game over sound if playing
            if (gameOverSoundPlaying) {
                gameOverSound.pause();
                gameOverSound.currentTime = 0;
                gameOverSoundPlaying = false;
            }
            
            // Reset background music volume and restart it with fade in
            backgroundSound.volume = 0.1; // Start at low volume
            playBackgroundMusic();
            fadeAudioVolume(backgroundSound, 0.1, 0.5, 250); // Fade from 0.1 to 0.5 over 250ms
            
            // Play vessel startup sound
            vesselStartupSound.currentTime = 0;
            vesselStartupSound.play().catch(err => console.log("Could not play vessel startup sound:", err));
        }

        function emitDustParticles(deltaTimeSec) {
            const groundY = getTerrainHeightAt(lander.x);
            const heightAboveTerrain = groundY - (lander.y + 20);

            const emissionThreshold = 100;
            if (heightAboveTerrain > emissionThreshold) return;

            const proximity = Math.max(0, emissionThreshold - heightAboveTerrain);
            const emissionRate = proximity / emissionThreshold;

            const maxParticlesPerFrame = 5;
            const particlesToEmit = Math.floor(emissionRate * maxParticlesPerFrame);

            for (let i = 0; i < particlesToEmit; i++) {
                const offsetX = (Math.random() - 0.5) * 20;
                const dustX = lander.x + offsetX;
                const dustY = groundY;

                const angle = (Math.random() * Math.PI / 2) + Math.PI / 4;
                const speed = Math.random() * 50 + 50;
                const vx = speed * Math.cos(angle) * (Math.random() < 0.5 ? -1 : 2);
                const vy = speed * Math.sin(angle) * -1;

                dustParticles.push({
                    x: dustX,
                    y: dustY,
                    vx: vx,
                    vy: vy,
                    size: Math.random() * 2 + 1,
                    alpha: 1.0,
                    lifespan: 1.0,
                });
            }
        }

        function updateDustParticles(deltaTimeSec) {
            for (let dust of dustParticles) {
                dust.x += dust.vx * deltaTimeSec;
                dust.y += dust.vy * deltaTimeSec;
                dust.vy += gravity * deltaTimeSec * 0.2;
                dust.lifespan -= deltaTimeSec;
                dust.alpha = Math.max(dust.lifespan / 1.0, 0);
            }
            dustParticles = dustParticles.filter(dust => dust.alpha > 0 && dust.x > cameraX - 50 && dust.x < cameraX + width + 50 && dust.y > cameraY - 50 && dust.y < cameraY + height + 50);
        }

        function updateMeteorites(deltaTimeSec) {
            if (Math.random() < 0.0001) {
                let fromLeft = Math.random() < 0.5;
                let x = fromLeft ? cameraX - 200 : cameraX + width + 200;
                let y = cameraY - 100;
                let angle = fromLeft ? Math.PI / 4 : (3 * Math.PI) / 4;
                let speed = 200 + Math.random() * 100;

                meteorites.push({
                    x,
                    y,
                    vx: speed * Math.cos(angle),
                    vy: speed * Math.sin(angle),
                    exploded: false,
                });
            }

            for (let meteor of meteorites) {
                if (!meteor.exploded) {
                    meteor.x += meteor.vx * deltaTimeSec;
                    meteor.y += meteor.vy * deltaTimeSec;
                    meteor.vy += gravity * deltaTimeSec;

                    let groundY = getTerrainHeightAt(meteor.x);
                    if (meteor.y >= groundY) {
                        meteor.exploded = true;
                        meteor.explosionParticles = [];
                        let numParticles = 15;
                        for (let i = 0; i < numParticles; i++) {
                            meteor.explosionParticles.push({
                                x: meteor.x,
                                y: groundY,
                                vx: (Math.random() - 0.5) * 100,
                                vy: (Math.random() - 0.5) * 100,
                                alpha: 1.0,
                            });
                        }
                        craterMarks.push({
                            x: meteor.x,
                            y: groundY,
                            radius: 20 + Math.random() * 10,
                        });
                    }

                    let dx = meteor.x - lander.x;
                    let dy = meteor.y - lander.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 20 && !lander.crashed) {
                        meteor.exploded = true;
                        crash();
                        meteorites.splice(meteorites.indexOf(meteor), 1);
                        continue;
                    }

                } else {
                    for (let particle of meteor.explosionParticles) {
                        particle.x += particle.vx * deltaTimeSec;
                        particle.y += particle.vy * deltaTimeSec;
                        particle.vy += gravity * deltaTimeSec;
                        particle.alpha -= deltaTimeSec * 0.5;
                    }
                    meteor.explosionParticles = meteor.explosionParticles.filter(p => p.alpha > 0);
                }
            }
            meteorites = meteorites.filter(meteor => !meteor.exploded || meteor.explosionParticles.length > 0);
        }

        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            let deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        function showControlsInstructions() {
            const controlsGuide = document.createElement('div');
            controlsGuide.id = 'controlsGuide';
            controlsGuide.innerHTML = `
                <h3 style="text-align: center; margin-top: 0;">CONTROLS</h3>
                
                <div class="control-row">
                    <div class="key">↑</div>
                    <div class="control-description">Main Thruster</div>
                </div>
                
                <div class="control-row">
                    <div class="key">←</div>
                    <div class="key">→</div>
                    <div class="control-description">Rotate Lander</div>
                </div>
                
                <div class="control-row">
                    <div class="key">A</div>
                    <div class="key">D</div>
                    <div class="control-description">Translation Thrusters (Side Movement)</div>
                </div>
            `;
            
            const startButton = document.getElementById('startButton');
            loadingScreen.insertBefore(controlsGuide, startButton);
        }
    </script>
</body>
</html>