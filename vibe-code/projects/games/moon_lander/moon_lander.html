<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Moon Lander Game</title>
    <link rel="stylesheet" href="moon_lander.css">
    <style>
        /* Add canvas background with deep blue gradient */
        canvas {
            display: block;
            background: radial-gradient(circle at top, #000022, #000000);
        }
        
        /* Mobile touch controls styling */
        #touchControls {
            display: none; /* Hidden by default, shown on mobile */
            position: fixed;
            bottom: 10px;
            left: 0;
            right: 0;
            z-index: 100;
            text-align: center;
            pointer-events: none; /* Allow clicks to pass through the container */
        }
        
        .control-pad {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .touch-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            margin: 0 5px;
            pointer-events: auto; /* Make buttons clickable */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .touch-btn:active, .touch-btn.active {
            background-color: rgba(255, 255, 255, 0.5);
        }
        
        /* Mobile HUD adjustments */
        @media (max-width: 768px) {
            #mini-hud {
                top: 10px !important;
                left: 5px !important;
                width: 45% !important;
                max-width: none !important;
                margin: 0 !important;
            }
            
            #hud {
                top: 10px !important;
                right: 5px !important;
                left: auto !important;
                bottom: auto !important;
                width: 45% !important;
                font-size: 17px !important;
                padding: 5px !important;
                margin: 0 !important;
                background-color: rgba(0, 0, 0, 0.5) !important;
                border-radius: 5px !important;
                white-space: nowrap !important;
                line-height: 1.2 !important;
                max-height: fit-content !important;
                overflow: hidden !important;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Touch controls for mobile devices -->
    <div id="touchControls">
        <div class="control-pad">
            <div id="leftRotateBtn" class="touch-btn">↺</div>
            <div id="mainThrustBtn" class="touch-btn">▲</div>
            <div id="rightRotateBtn" class="touch-btn">↻</div>
        </div>
        <div class="control-pad">
            <div id="leftTranslateBtn" class="touch-btn">▶</div>
            <div id="rightTranslateBtn" class="touch-btn">◀</div>
        </div>
    </div>
    
    <!-- Mini HUD for oxygen and fuel -->
    <div id="mini-hud">
        <div class="mini-label">
            <span>OXYGEN</span>
            <span id="mini-oxygen-value">100%</span>
        </div>
        <div class="mini-bar-container">
            <div id="mini-oxygen-bar"></div>
        </div>
        
        <div class="mini-label">
            <span>FUEL</span>
            <span id="mini-fuel-value">100%</span>
        </div>
        <div class="mini-bar-container">
            <div id="mini-fuel-bar"></div>
        </div>
    </div>
    
    <!-- Simplified HUD without oxygen and fuel -->
    <div id="hud">
        Score: <span id="scoreValue">0</span><br>
        High Score: <span id="highScoreValue">0</span><br>
        Vertical Velocity: <span id="verticalVelocityValue">0</span><br>
        Horizontal Velocity: <span id="horizontalVelocityValue">0</span><br>
        Height: <span id="heightValue">0m</span>
    </div>

    <div id="message">
        <div id="gameMessage">Game Over!</div>
        <button id="restartButton">Restart</button>
    </div>
    <div id="loadingScreen">
        <div id="progressContainer">
            <div id="progressBar"></div>
        </div>
        <div id="progressText">0%</div>
        <button id="startButton">START MISSION</button>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        // Mobile detection and setup
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const touchControls = document.getElementById('touchControls');
        
        // Show touch controls on mobile devices
        if (isMobile) {
            touchControls.style.display = 'block';
            
            // Adjust HUD positioning for better mobile visibility
            document.getElementById('mini-hud').style.maxWidth = '250px';
            document.getElementById('hud').style.padding = '5px';
            document.getElementById('hud').style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            
            // Prevent default touch actions to avoid scrolling while playing
            document.body.addEventListener('touchstart', function(e) {
                if (e.target.closest('#touchControls')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.body.addEventListener('touchmove', function(e) {
                if (gameStarted) {
                    e.preventDefault();
                }
            }, { passive: false });
        }
        
        // Touch control buttons
        const mainThrustBtn = document.getElementById('mainThrustBtn');
        const leftRotateBtn = document.getElementById('leftRotateBtn');
        const rightRotateBtn = document.getElementById('rightRotateBtn');
        const leftTranslateBtn = document.getElementById('leftTranslateBtn');
        const rightTranslateBtn = document.getElementById('rightTranslateBtn');
        
        // Touch control event listeners
        function setupTouchControls() {
            // Main thrust (Up arrow)
            mainThrustBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['arrowup'] = true;
                this.classList.add('active');
                
                // If main thruster was just activated, record the time
                if (!mainThrusterStartTime) {
                    mainThrusterStartTime = Date.now();
                    
                    // Cancel any pending pump reset sound when thruster is reactivated
                    if (mainThrusterReleaseTimer !== null) {
                        clearTimeout(mainThrusterReleaseTimer);
                        mainThrusterReleaseTimer = null;
                    }
                }
            });
            
            mainThrustBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['arrowup'] = false;
                this.classList.remove('active');
                
                // Similar logic to keyup handler for the pump reset sound
                if (mainEngineSoundPlaying) {
                    const thrusterDuration = Date.now() - mainThrusterStartTime;
                    
                    if (thrusterDuration >= MIN_THRUSTER_TIME) {
                        if (mainThrusterReleaseTimer !== null) {
                            clearTimeout(mainThrusterReleaseTimer);
                        }
                        
                        mainThrusterReleaseTimer = setTimeout(() => {
                            pumpResetSound.currentTime = 0;
                            pumpResetSound.play();
                            mainThrusterReleaseTimer = null;
                        }, 1500);
                    }
                }
                mainThrusterStartTime = null;
            });
            
            // Left rotation (Left arrow)
            leftRotateBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['arrowleft'] = true;
                this.classList.add('active');
            });
            
            leftRotateBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['arrowleft'] = false;
                this.classList.remove('active');
            });
            
            // Right rotation (Right arrow)
            rightRotateBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['arrowright'] = true;
                this.classList.add('active');
            });
            
            rightRotateBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['arrowright'] = false;
                this.classList.remove('active');
            });
            
            // Left translation (A key)
            leftTranslateBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['a'] = true;
                this.classList.add('active');
            });
            
            leftTranslateBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['a'] = false;
                this.classList.remove('active');
            });
            
            // Right translation (D key)
            rightTranslateBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['d'] = true;
                this.classList.add('active');
            });
            
            rightTranslateBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['d'] = false;
                this.classList.remove('active');
            });
        }
        
        // Set up touch controls if on mobile
        if (isMobile) {
            setupTouchControls();
        }

        // Loading screen elements
        const loadingScreen = document.getElementById('loadingScreen');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const startButton = document.getElementById('startButton');
        
        // Audio loading tracking
        const soundFiles = {
            mainEngine: { src: 'main_engine.mp3', loaded: false },
            rotationEngine: { src: 'rotation_engine.mp3', loaded: false },
            breathing: { src: 'breathing.mp3', loaded: false },
            background: { src: 'background.mp3', loaded: false },
            crash: { src: 'crash_2.mp3', loaded: false },
            fuelUp: { src: 'fuel_up.mp3', loaded: false },
            pumpReset: { src: 'pump_reset.mp3', loaded: false },
            riser: { src: 'riser.mp3', loaded: false },
            gameOver: { src: 'game_over.mp3', loaded: false },
            vesselStartup: { src: 'vessel_startup.mp3', loaded: false } // Add vessel startup sound
        };
        
        let totalSounds = Object.keys(soundFiles).length;
        let loadedSounds = 0;
        let gameStarted = false;

        // Audio setup with loading handlers
        const mainEngineSound = new Audio();
        mainEngineSound.src = soundFiles.mainEngine.src;
        mainEngineSound.loop = true;
        
        const rotationEngineSound = new Audio();
        rotationEngineSound.src = soundFiles.rotationEngine.src;
        rotationEngineSound.loop = true;
        
        const breathingSound = new Audio();
        breathingSound.src = soundFiles.breathing.src;
        breathingSound.loop = false;
        
        const backgroundSound = new Audio();
        backgroundSound.src = soundFiles.background.src;
        backgroundSound.loop = true;
        backgroundSound.preload = "auto"; // Ensure preloading
        
        const crashSound = new Audio();
        crashSound.src = soundFiles.crash.src;

        const fuelUpSound = new Audio('fuel_up.mp3');
        fuelUpSound.volume = 0.7;
        fuelUpSound.preload = "auto"; // Ensure it's preloaded
        
        const pumpResetSound = new Audio('pump_reset.mp3');
        pumpResetSound.volume = 0.6;

        const riserSound = new Audio('riser.mp3');
        riserSound.volume = 0.7;
        riserSound.loop = false;
        
        const gameOverSound = new Audio('game_over.mp3');
        gameOverSound.loop = true;
        gameOverSound.volume = 0.5;

        const vesselStartupSound = new Audio('vessel_startup.mp3');
        vesselStartupSound.volume = 0.15;

        let riserSoundPlaying = false;
        let gameOverSoundPlaying = false;
        const LOW_OXYGEN_THRESHOLD = 5; // 4 seconds threshold
        
        let mainThrusterReleaseTimer = null;
        let mainThrusterStartTime = null; // Track when the main thruster was activated
        const MIN_THRUSTER_TIME = 2750; // Minimum time in ms the thruster must be active (2.75 seconds)

        // Game over messages
        const gameOverMessages = [
        "You're alone now. Only silence answers your calls.",
        "The stars look closer, but no one is coming.",
        "This was never meant to be your grave.",
        "No one knows you’re here. No one ever will.",
        "Out here, your screams are forever silent.",
        "The darkness sees you—but it doesn't care.",
        "Home is just a distant memory now.",
        "Forever trapped in the vastness between worlds.",
        "Space takes without remorse or mercy.",
        "How small you are, beneath an uncaring sky.",
        "No signal. No rescue. Just emptiness.",
        "Your footprints vanish. No one will follow.",
        "Space swallows all hope eventually.",
        "You left Earth, but you'll never return.",
        "The universe never promised you'd survive.",
        "You were brave to venture this far—but now you're alone.",
        "Stars shine brighter as your vision fades.",
        "Silence reigns eternal beyond this point.",
        "You’re not the first to be lost out here.",
        "Even the stars look cold tonight.",
        "You call for help, but only echoes reply.",
        "Your journey ends here, lost in endless void.",
        "You reached for the stars—but the void took you."
        ];
    
        
        // Add loading event listeners
        mainEngineSound.addEventListener('canplaythrough', () => handleSoundLoaded('mainEngine'));
        rotationEngineSound.addEventListener('canplaythrough', () => handleSoundLoaded('rotationEngine'));
        breathingSound.addEventListener('canplaythrough', () => handleSoundLoaded('breathing'));
        backgroundSound.addEventListener('canplaythrough', () => handleSoundLoaded('background'));
        crashSound.addEventListener('canplaythrough', () => handleSoundLoaded('crash'));
        fuelUpSound.addEventListener('canplaythrough', () => handleSoundLoaded('fuelUp'));
        pumpResetSound.addEventListener('canplaythrough', () => handleSoundLoaded('pumpReset'));
        riserSound.addEventListener('canplaythrough', () => handleSoundLoaded('riser'));
        gameOverSound.addEventListener('canplaythrough', () => handleSoundLoaded('gameOver'));
        vesselStartupSound.addEventListener('canplaythrough', () => handleSoundLoaded('vesselStartup'));
        
        // Add event listener to start button
        startButton.addEventListener('click', startGame);

        // Handle sound loading
        function handleSoundLoaded(soundName) {
            if (!soundFiles[soundName].loaded) {
                soundFiles[soundName].loaded = true;
                loadedSounds++;
                
                // Update loading progress
                const progress = Math.floor((loadedSounds / totalSounds) * 100);
                progressBar.style.width = `${progress}%`;
                progressText.textContent = `${progress}%`;
                
                // Show start button and controls when all sounds are loaded
                if (loadedSounds === totalSounds) {
                    setTimeout(() => {
                        progressContainer.style.display = "none";
                        progressText.style.display = "none";
                        startButton.style.display = "block";
                        showControlsInstructions();
                    }, 500); // Small delay for visual feedback
                }
            }
        }
        
        // Set volume for sounds
        mainEngineSound.volume = 0.5;
        rotationEngineSound.volume = 0.40;
        backgroundSound.volume = 0.5;
        crashSound.volume = 0.40;
        breathingSound.volume = 1.00;

        let mainEngineSoundPlaying = false;
        let rotationEngineSoundPlaying = false;
        let breathingSoundPlaying = false;
        let translationEngineSoundPlaying = false; // New variable for A/D thrusters
        
        // Stars
        let stars = [];
        const NUM_STARS = 800;
        const STAR_COLOR = 'white';
        const STAR_MIN_RADIUS = 0.5;
        const STAR_MAX_RADIUS = 1.5;

        function generateStars() {
            stars = [];
            for (let i = 0; i < NUM_STARS; i++) {
                stars.push({
                    x: Math.random() * width * 2,
                    y: Math.random() * height * 2,
                    radius: Math.random() * (STAR_MAX_RADIUS - STAR_MIN_RADIUS) + STAR_MIN_RADIUS,
                    alpha: Math.random() * 0.5 + 0.5,
                    twinkleSpeed: Math.random() * 0.010 + 0.005,
                    twinkleDirection: Math.random() < 0.5 ? 1 : -1,
                    parallax: Math.random() * 0.5 + 0.5
                });
            }
        }
        generateStars();

        // Function to start the game after loading
        function startGame() {
            gameStarted = true;
            loadingScreen.style.display = 'none';
            
            // Make sure background music starts playing
            playBackgroundMusic();
            
            requestAnimationFrame(gameLoop);
        }

        // Function to ensure background music starts playing
        function playBackgroundMusic() {
            // Check if the sound is loaded and ready
            if (backgroundSound.readyState >= 2) { // HAVE_CURRENT_DATA or higher
                backgroundSound.currentTime = 0; // Reset to beginning
                
                // Use Promise to handle autoplay restrictions
                const playPromise = backgroundSound.play();
                
                // Handle potential promise rejection due to autoplay policies
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log("Autoplay prevented, adding click listener");
                        // Add a one-time click listener to start audio if autoplay is blocked
                        document.addEventListener('click', function startAudioOnClick() {
                            backgroundSound.play();
                            document.removeEventListener('click', startAudioOnClick);
                        });
                    });
                }
            } else {
                // If not ready, set up event listener to play when ready
                backgroundSound.addEventListener('canplaythrough', function playWhenReady() {
                    backgroundSound.play();
                    backgroundSound.removeEventListener('canplaythrough', playWhenReady);
                });
            }
        }

        // Function to fade audio volume smoothly
        function fadeAudioVolume(audioElement, startVolume, endVolume, durationMs) {
            const startTime = Date.now();
            const volumeChange = endVolume - startVolume;
            
            // Store original volume to restore if needed
            const originalVolume = audioElement.volume;
            audioElement.volume = startVolume;
            
            // Fade function that will be called repeatedly
            function updateVolume() {
                const currentTime = Date.now();
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / durationMs, 1);
                
                // Calculate new volume using linear interpolation
                const newVolume = startVolume + volumeChange * progress;
                audioElement.volume = newVolume;
                
                // Continue fading if not complete
                if (progress < 1) {
                    requestAnimationFrame(updateVolume);
                }
            }
            
            // Start the fade process
            requestAnimationFrame(updateVolume);
            
            // Return original volume for potential restoration
            return originalVolume;
        }

        // Game variables
        let oxygen = 70;
        let fuel = 1900;
        let score = 0;
        let gameOver = false;

        let highScore = localStorage.getItem('moonLanderHighScore') || 0;

        let gravity = 27;

        const lander = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            mass: 1,
            crashed: false,
            landed: false,
            explosionParticles: [],
            debrisParticles: [], // Add debris array to store lander parts after crash
            currentPlatform: null,
            speed: 0,
            controlsDisabled: false,
            crashTime: null, // Track when crash occurred
            gameOverShown: false // Flag for showing game over message
        };

        const keys = {};

        let terrain = [];
        let landingZones = [];
        let rocks = [];
        let craterMarks = [];
        let meteorites = [];

        let cameraX = 0;
        let cameraY = 0;

        let dustParticles = [];

        function generateLandscape() {
            terrain = [];
            landingZones = [];
            craterMarks = [];
            rocks = [];
            let points = [];
            let numPoints = 8000;
            let segmentWidth = 300;
            for (let i = 0; i <= numPoints; i++) {
                let x = i * segmentWidth;
                let y = height - Math.random() * 360 - 100;
                points.push({ x, y });
            }

            let platformSpacing = 200;
            let lastPlatformX = -platformSpacing;
            let platformsCreated = 0;

            for (let i = 2; i < points.length - 2; i++) {
                let x = points[i].x;
                if (Math.abs(x - lastPlatformX) < platformSpacing) continue;

                let y = Math.min(points[i].y, points[i + 1].y);
                let platformWidth = 50 + Math.random() * 100;

                let leftSlope = Math.abs(points[i].y - points[i - 1].y);
                let rightSlope = Math.abs(points[i + 2].y - points[i + 1].y);
                if (leftSlope > 100 || rightSlope > 100) continue;

                landingZones.push({
                    x,
                    y,
                    width: platformWidth,
                    landed: false,
                    points: Math.floor(200 - platformWidth),
                });

                points[i].y = y;
                points[i + 1].y = y;
                points[i + 1].x = x + platformWidth;

                lastPlatformX = x;
                platformsCreated++;
            }

            if (landingZones.length === 0) {
                let index = Math.floor(numPoints / 2);
                let x = points[index].x;
                let y = points[index].y;
                let platformWidth = 150;

                landingZones.push({
                    x,
                    y,
                    width: platformWidth,
                    landed: false,
                    points: Math.floor(200 - platformWidth),
                });
                points[index].y = y;
                points[index + 1].y = y;
                points[index + 1].x = x + platformWidth;
            }

            terrain = points;

            if (landingZones.length > 0) {
                let startingZone = landingZones[Math.floor(Math.random() * landingZones.length)];
                lander.x = startingZone.x + startingZone.width / 2;
                lander.y = startingZone.y - 200;
                cameraX = lander.x - width / 1.5;
                cameraY = lander.y - height / 2;
            } else {
                lander.x = width / 2;
                lander.y = height / 2;
                cameraX = lander.x - width / 2;
                cameraY = lander.y - height / 2;
            }

            for (let i = 0; i < 50; i++) {
                let craterX = Math.random() * terrain[terrain.length - 1].x;
                let craterY = getTerrainHeightAt(craterX);
                craterMarks.push({
                    x: craterX,
                    y: craterY,
                    radius: 10 + Math.random() * 15,
                });
            }

            for (let i = 0; i < 100; i++) {
                let rockX = Math.random() * terrain[terrain.length - 1].x;
                let rockY = getTerrainHeightAt(rockX);
                rocks.push({
                    x: rockX,
                    y: rockY,
                    size: 2 + Math.random() * 3,
                });
            }
        }

        generateLandscape();

        window.addEventListener('keydown', (e) => { 
            const key = e.key.toLowerCase();
            
            // If this is the first time the key is pressed (not a key repeat event)
            if (!keys[key]) {
                // Track when Arrow Up key is first pressed down
                if (key === 'arrowup') {
                    mainThrusterStartTime = Date.now();
                    
                    // Cancel any pending pump reset sound when thruster is reactivated
                    if (mainThrusterReleaseTimer !== null) {
                        clearTimeout(mainThrusterReleaseTimer);
                        mainThrusterReleaseTimer = null;
                    }
                }
            }
            
            keys[key] = true;
        });
        
        window.addEventListener('keyup', (e) => { 
            keys[e.key.toLowerCase()] = false; 
            
            // When arrow up key is released, check if we should play pump reset sound
            if (e.key === 'ArrowUp' && mainEngineSoundPlaying) {
                const thrusterDuration = Date.now() - mainThrusterStartTime;
                
                // Only schedule pump reset sound if thruster was active for minimum time
                if (thrusterDuration >= MIN_THRUSTER_TIME) {
                    // Clear any existing timer
                    if (mainThrusterReleaseTimer !== null) {
                        clearTimeout(mainThrusterReleaseTimer);
                    }
                    
                    // Set new timer for 1.5 second delay
                    mainThrusterReleaseTimer = setTimeout(() => {
                        pumpResetSound.currentTime = 0;
                        pumpResetSound.play();
                        mainThrusterReleaseTimer = null;
                    }, 1500);
                }
            }
        });
        window.addEventListener('resize', onResize);
        document.getElementById('restartButton').addEventListener('click', restartGame);

        function onResize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            generateStars();
            generateLandscape();
            updateHUD();
            
            // Reposition touch controls based on new screen size if mobile
            if (isMobile) {
                // Adjust control positions based on new dimensions
                const controlHeight = touchControls.offsetHeight;
                document.getElementById('hud').style.bottom = (controlHeight + 10) + 'px';
            }
        }

        function getTerrainHeightAt(x) {
            for (let i = 0; i < terrain.length - 1; i++) {
                let p1 = terrain[i];
                let p2 = terrain[i + 1];
                if (x >= p1.x && x <= p2.x) {
                    let m = (p2.y - p1.y) / (p2.x - p1.x);
                    let b = p1.y - m * p1.x;
                    let groundY = m * x + b;
                    return groundY;
                }
            }
            return height;
        }

        function update(deltaTime) {
            if (gameOver) {
                // Keep updating debris even after game over
                let deltaTimeSec = deltaTime / 1000;
                updateDebrisAfterGameOver(deltaTimeSec);
                return;
            }

            let deltaTimeSec = deltaTime / 1000;

            if (lander.crashed) {
                for (let particle of lander.explosionParticles) {
                    particle.x += particle.vx * deltaTimeSec;
                    particle.y += particle.vy * deltaTimeSec;
                    particle.vy += gravity * deltaTimeSec;
                    particle.alpha -= deltaTimeSec;
                }
                lander.explosionParticles = lander.explosionParticles.filter(p => p.alpha > 0);

                // Update debris particles
                for (let debris of lander.debrisParticles) {
                    // Update position based on velocity
                    debris.x += debris.vx * deltaTimeSec;
                    debris.y += debris.vy * deltaTimeSec;
                    
                    // Apply gravity
                    debris.vy += gravity * deltaTimeSec;
                    
                    // Update rotation
                    debris.angle += debris.angularVelocity * deltaTimeSec;
                    
                    // Check for collision with ground
                    const groundY = getTerrainHeightAt(debris.x);
                    if (debris.y + debris.height/2 >= groundY) {
                        // Position correction - place on ground
                        debris.y = groundY - debris.height/2;
                        
                        // Bounce with energy loss
                        if (Math.abs(debris.vy) > 5) {
                            debris.vy = -debris.vy * 0.4; // 60% energy loss on bounce
                            debris.vx *= 0.7; // Friction with ground
                            debris.angularVelocity *= 0.7; // Reduce spin
                        } else {
                            // Come to rest
                            debris.vy = 0;
                            debris.vx *= 0.95; // Friction when sliding
                            debris.angularVelocity *= 0.95; // Reduce spin further
                            
                            // Stop completely at very low speeds
                            if (Math.abs(debris.vx) < 1) debris.vx = 0;
                            if (Math.abs(debris.angularVelocity) < 0.1) debris.angularVelocity = 0;
                        }
                    }
                }

                // Show game over message after a short delay but don't wait for debris to settle
                if (lander.crashTime && Date.now() - lander.crashTime > 1500 && !lander.gameOverShown) {
                    lander.gameOverShown = true;
                    endGame('Crash! \n Game Over. \n Final Score: ' + score);
                }
                return;
            }

            oxygen -= deltaTimeSec;
            if (oxygen <= 0) {
                oxygen = 0;
                lander.controlsDisabled = true;
                if (breathingSoundPlaying) {
                    breathingSound.pause();
                    breathingSound.currentTime = 0;
                    breathingSoundPlaying = false;
                }
                if (lander.landed && !lander.crashed) {
                    endGame('Out of Oxygen! Game Over. Final Score: ' + score);
                }
            }

            // Handle low oxygen alarm (riser sound)
            if (oxygen <= LOW_OXYGEN_THRESHOLD && oxygen > 0) {
                if (!riserSoundPlaying) {
                    riserSound.currentTime = 0;
                    riserSound.play();
                    riserSoundPlaying = true;
                }
            } else {
                if (riserSoundPlaying) {
                    riserSound.pause();
                    riserSound.currentTime = 0;
                    riserSoundPlaying = false;
                }
            }

            if (oxygen <= 10 && oxygen > 0) {
                if (!breathingSoundPlaying) {
                    breathingSound.play();
                    breathingSoundPlaying = true;
                }
            } else {
                if (breathingSoundPlaying) {
                    breathingSound.pause();
                    breathingSound.currentTime = 0;
                    breathingSoundPlaying = false;
                }
            }

            if (!lander.controlsDisabled && fuel > 0) {
                if (keys['arrowup']) {
                    let thrust = 65;
                    let adjustedThrust = thrust * (1 + (1900 - fuel) / 1900);
                    lander.vx += adjustedThrust * Math.sin(lander.angle) * deltaTimeSec;
                    lander.vy -= adjustedThrust * Math.cos(lander.angle) * deltaTimeSec;
                    fuel -= 0.49;

                    emitDustParticles(deltaTimeSec);
                }
                if (keys['arrowleft']) {
                    lander.angularVelocity -= 90 * Math.PI / 180 * deltaTimeSec;
                    fuel -= 0.14;
                }
                if (keys['arrowright']) {
                    lander.angularVelocity += 90 * Math.PI / 180 * deltaTimeSec;
                    fuel -= 0.14;
                }
                if (keys['d']) {
                    let thrust = 27;
                    lander.vx += thrust * Math.sin(lander.angle - Math.PI / 2) * deltaTimeSec;
                    lander.vy -= thrust * Math.cos(lander.angle - Math.PI / 2) * deltaTimeSec;
                    fuel -= 0.14;
                }
                if (keys['a']) {
                    let thrust = 27;
                    lander.vx += thrust * Math.sin(lander.angle + Math.PI / 2) * deltaTimeSec;
                    lander.vy -= thrust * Math.cos(lander.angle + Math.PI / 2) * deltaTimeSec;
                    fuel -= 0.14;
                }
            }

            if (!lander.controlsDisabled && fuel > 0 && !lander.crashed) {
                if (keys['arrowup']) {
                    if (!mainEngineSoundPlaying) {
                        mainEngineSound.play();
                        mainEngineSoundPlaying = true;
                    }
                } else {
                    if (mainEngineSoundPlaying) {
                        mainEngineSound.pause();
                        mainEngineSound.currentTime = 0;
                        mainEngineSoundPlaying = false;
                    }
                }
            } else {
                if (mainEngineSoundPlaying) {
                    mainEngineSound.pause();
                    mainEngineSound.currentTime = 0;
                    mainEngineSoundPlaying = false;
                }
            }

            if (!lander.controlsDisabled && fuel > 0 && !lander.crashed) {
                if (keys['a'] || keys['d']) {
                    if (!translationEngineSoundPlaying) {
                        rotationEngineSound.play();
                        translationEngineSoundPlaying = true;
                    }
                } else {
                    if (translationEngineSoundPlaying) {
                        if (!keys['arrowleft'] && !keys['arrowright']) {
                            rotationEngineSound.pause();
                            rotationEngineSound.currentTime = 0;
                        }
                        translationEngineSoundPlaying = false;
                    }
                }
            } else {
                if (translationEngineSoundPlaying) {
                    if (!rotationEngineSoundPlaying) {
                        rotationEngineSound.pause();
                        rotationEngineSound.currentTime = 0;
                    }
                    translationEngineSoundPlaying = false;
                }
            }

            if (!lander.controlsDisabled && fuel > 0 && !lander.crashed) {
                if (keys['arrowleft'] || keys['arrowright']) {
                    if (!rotationEngineSoundPlaying) {
                        if (!translationEngineSoundPlaying) {
                            rotationEngineSound.play();
                        }
                        rotationEngineSoundPlaying = true;
                    }
                } else {
                    if (rotationEngineSoundPlaying) {
                        if (!translationEngineSoundPlaying) {
                            rotationEngineSound.pause();
                            rotationEngineSound.currentTime = 0;
                        }
                        rotationEngineSoundPlaying = false;
                    }
                }
            } else {
                if (rotationEngineSoundPlaying) {
                    if (!translationEngineSoundPlaying) {
                        rotationEngineSound.pause();
                        rotationEngineSound.currentTime = 0;
                    }
                    rotationEngineSoundPlaying = false;
                }
            }

            lander.vy += gravity * deltaTimeSec;
            lander.x += lander.vx * deltaTimeSec;
            lander.y += lander.vy * deltaTimeSec;
            lander.angle += lander.angularVelocity * deltaTimeSec;

            if (lander.angle > Math.PI) lander.angle -= 2 * Math.PI;
            if (lander.angle < -Math.PI) lander.angle += 2 * Math.PI;

            lander.speed = Math.sqrt(lander.vx * lander.vx + lander.vy * lander.vy);

            let leftBoundary = cameraX + width / 3;
            let rightBoundary = cameraX + (2 * width) / 3;

            if (lander.x < leftBoundary) {
                cameraX -= (leftBoundary - lander.x) * 0.1;
            } else if (lander.x > rightBoundary) {
                cameraX += (lander.x - rightBoundary) * 0.1;
            }

            let topBoundary = cameraY + height * 0.2;
            let bottomBoundary = cameraY + height * 0.6;

            if (lander.y < topBoundary) {
                cameraY -= (topBoundary - lander.y) * 0.1;
            } else if (lander.y > bottomBoundary) {
                cameraY += (lander.y - bottomBoundary) * 0.1;
            }

            let landerBottom = { x: lander.x, y: lander.y + 20 };
            for (let i = 0; i < terrain.length - 1; i++) {
                let p1 = terrain[i];
                let p2 = terrain[i + 1];
                if (landerBottom.x >= p1.x && landerBottom.x <= p2.x) {
                    let m = (p2.y - p1.y) / (p2.x - p1.x);
                    let b = p1.y - m * p1.x;
                    let groundY = m * landerBottom.x + b;
                    if (landerBottom.y >= groundY) {
                        lander.y = groundY - 20;

                        let safeLandingSpeed = 57;
                        let verticalSpeed = lander.vy;

                        lander.vx = 0;
                        lander.vy = 0;
                        lander.angularVelocity = 0;

                        if (verticalSpeed > safeLandingSpeed || Math.abs(lander.angle) > Math.PI / 6) {
                            crash();
                        } else {
                            let landedOnPlatform = false;
                            for (let zone of landingZones) {
                                if (lander.x >= zone.x && lander.x <= zone.x + zone.width) {
                                    landedOnPlatform = true;
                                    if (!zone.landed) {
                                        successfulLanding(zone);
                                        zone.landed = true;
                                        lander.currentPlatform = zone;
                                    } else {
                                        lander.currentPlatform = zone;
                                    }
                                    break;
                                }
                            }
                            if (!landedOnPlatform) {
                                crash();
                            } else {
                                lander.landed = true;
                                if (oxygen <= 0) {
                                    endGame('Out of Oxygen! Game Over. Final Score: ' + score);
                                }
                            }
                        }
                        break;
                    }
                }
            }

            if (lander.landed && lander.y + 20 < lander.currentPlatform.y - 1) {
                lander.landed = false;
                lander.currentPlatform = null;
            }

            updateMeteorites(deltaTimeSec);
            updateDustParticles(deltaTimeSec);
            updateHUD();
        }
        
        // Function to keep updating debris after game over is shown
        function updateDebrisAfterGameOver(deltaTimeSec) {
            if (!lander.crashed) return;
            
            // Continue updating debris particles
            for (let debris of lander.debrisParticles) {
                debris.x += debris.vx * deltaTimeSec;
                debris.y += debris.vy * deltaTimeSec;
                debris.vy += gravity * deltaTimeSec;
                debris.angle += debris.angularVelocity * deltaTimeSec;
                
                const groundY = getTerrainHeightAt(debris.x);
                if (debris.y + debris.height/2 >= groundY) {
                    debris.y = groundY - debris.height/2;
                    
                    if (Math.abs(debris.vy) > 5) {
                        debris.vy = -debris.vy * 0.4;
                        debris.vx *= 0.7;
                        debris.angularVelocity *= 0.7;
                    } else {
                        debris.vy = 0;
                        debris.vx *= 0.95;
                        debris.angularVelocity *= 0.95;
                        
                        if (Math.abs(debris.vx) < 1) debris.vx = 0;
                        if (Math.abs(debris.angularVelocity) < 0.1) debris.angularVelocity = 0;
                    }
                }
            }
            
            // Also update explosion particles
            for (let particle of lander.explosionParticles) {
                particle.x += particle.vx * deltaTimeSec;
                particle.y += particle.vy * deltaTimeSec;
                particle.vy += gravity * deltaTimeSec;
                particle.alpha -= deltaTimeSec;
            }
            lander.explosionParticles = lander.explosionParticles.filter(p => p.alpha > 0);
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            ctx.save();
            for (let star of stars) {
                star.x -= lander.vx * 0.00010 * star.parallax;
                star.y -= lander.vy * 0.00010 * star.parallax;

                star.alpha += star.twinkleSpeed * star.twinkleDirection;
                if (star.alpha >= 1.0) {
                    star.alpha = 1.0;
                    star.twinkleDirection = -1;
                } else if (star.alpha <= 0.5) {
                    star.alpha = 0.5;
                    star.twinkleDirection = 1;
                }

                ctx.globalAlpha = star.alpha;
                ctx.fillStyle = STAR_COLOR;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
            ctx.restore();

            ctx.save();
            ctx.translate(-cameraX, -cameraY);

            let terrainGradient = ctx.createLinearGradient(0, cameraY, 0, cameraY + height);
            terrainGradient.addColorStop(0, '#7B7B7B');
            terrainGradient.addColorStop(1, '#4B4B4B');

            ctx.fillStyle = terrainGradient;
            ctx.beginPath();
            ctx.moveTo(terrain[0].x, cameraY + height);
            for (let point of terrain) {
                ctx.lineTo(point.x, point.y);
            }
            ctx.lineTo(terrain[terrain.length - 1].x, cameraY + height);
            ctx.closePath();
            ctx.fill();

            for (let crater of craterMarks) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(crater.x, crater.y, crater.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = '#3D3D3D';
            for (let rock of rocks) {
                ctx.beginPath();
                ctx.arc(rock.x, rock.y, rock.size, 0, Math.PI * 2);
                ctx.fill();
            }

            for (let zone of landingZones) {
                ctx.fillStyle = zone.landed ? '#555555' : 'yellow';
                // Make landing pads more visible on mobile with a brighter outline
                if (isMobile) {
                    ctx.fillRect(zone.x, zone.y - 8, zone.width, 8); // Make slightly taller
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(zone.x, zone.y - 8, zone.width, 8);
                } else {
                    ctx.fillRect(zone.x, zone.y - 5, zone.width, 5);
                }
            }

            for (let meteor of meteorites) {
                if (!meteor.exploded) {
                    ctx.save();
                    ctx.translate(meteor.x, meteor.y);
                    ctx.fillStyle = 'gray';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            for (let meteor of meteorites) {
                if (meteor.exploded && meteor.explosionParticles) {
                    for (let particle of meteor.explosionParticles) {
                        ctx.save();
                        ctx.globalAlpha = particle.alpha;
                        ctx.fillStyle = 'orange';
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
            }

            for (let dust of dustParticles) {
                ctx.save();
                ctx.globalAlpha = dust.alpha;
                ctx.fillStyle = 'rgba(128,128,128, 0.6)';
                ctx.beginPath();
                ctx.arc(dust.x, dust.y, dust.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            if (lander.crashed) {
                // Draw explosion particles
                for (let particle of lander.explosionParticles) {
                    ctx.save();
                    ctx.globalAlpha = particle.alpha;
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Draw debris particles with more complex shapes
                for (let debris of lander.debrisParticles) {
                    ctx.save();
                    ctx.translate(debris.x, debris.y);
                    ctx.rotate(debris.angle);
                    
                    // Draw based on debris type
                    if (debris.type === 'hull') {
                        // Irregular hull fragment
                        let bodyGradient = ctx.createLinearGradient(-debris.width/2, 0, debris.width/2, 0);
                        bodyGradient.addColorStop(0, "#D0D0D8");
                        bodyGradient.addColorStop(0.5, "#F0F0F8");
                        bodyGradient.addColorStop(1, "#D0D0D8");
                        ctx.fillStyle = bodyGradient;
                        
                        // Create jagged/irregular hull shape
                        ctx.beginPath();
                        const jaggedFactor = debris.jaggedness;
                        ctx.moveTo(-debris.width/2, -debris.height/2 + jaggedFactor[0]);
                        ctx.lineTo(debris.width/2 - jaggedFactor[1], -debris.height/2);
                        ctx.lineTo(debris.width/2, debris.height/2 - jaggedFactor[2]);
                        ctx.lineTo(-debris.width/2 + jaggedFactor[3], debris.height/2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = '#999999';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // Add panel line detail if it's a larger piece
                        if (debris.width > 10) {
                            ctx.strokeStyle = '#AAAAAA';
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(-debris.width/3, -debris.height/3);
                            ctx.lineTo(debris.width/3, -debris.height/3);
                            ctx.stroke();
                        }
                    } 
                    else if (debris.type === 'viewport') {
                        // Broken viewport with gradient
                        let viewportGradient = ctx.createRadialGradient(1, -1, 0, 0, 0, debris.width/2);
                        viewportGradient.addColorStop(0, "#FFFFFF");
                        viewportGradient.addColorStop(0.3, "#8888FF");
                        viewportGradient.addColorStop(1, "#4444AA");
                        ctx.fillStyle = viewportGradient;
                        
                        // Create broken glass look with irregular segments
                        ctx.beginPath();
                        // Create a slightly irregular circle/oval for broken glass
                        const segments = 8;
                        const angleStep = (Math.PI * 2) / segments;
                        for (let i = 0; i < segments; i++) {
                            const angle = i * angleStep;
                            const radiusVar = debris.width/2 * (0.9 + Math.random() * 0.2);
                            const x = Math.cos(angle) * radiusVar;
                            const y = Math.sin(angle) * radiusVar;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        // Cracked look
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(-debris.width/3, 0);
                        ctx.lineTo(debris.width/3, 0);
                        ctx.stroke();
                        
                        ctx.strokeStyle = '#666666';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    else if (debris.type === 'leg') {
                        // Bent/broken landing leg
                        ctx.strokeStyle = '#777777';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        
                        // Add a bend in the middle to look broken
                        ctx.moveTo(0, -debris.height/2);
                        ctx.lineTo(debris.width/4, 0); // Bent part
                        ctx.lineTo(0, debris.height/2);
                        ctx.stroke();
                    }
                    else if (debris.type === 'thruster') {
                        // Damaged thruster with heat discoloration
                        const heatGradient = ctx.createLinearGradient(
                            -debris.width/2, 0, debris.width/2, 0
                        );
                        heatGradient.addColorStop(0, "#888888");
                        heatGradient.addColorStop(0.7, "#a86032");
                        heatGradient.addColorStop(1, "#c83000");
                        
                        ctx.fillStyle = heatGradient;
                        
                        // Irregular thruster shape
                        ctx.beginPath();
                        ctx.moveTo(-debris.width/2, -debris.height/2);
                        ctx.lineTo(debris.width/2, -debris.height/2 - Math.random() * 2);
                        ctx.lineTo(debris.width/2 + 1, debris.height/2);
                        ctx.lineTo(-debris.width/2 - 1, debris.height/2 + Math.random() * 2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Nozzle details
                        ctx.strokeStyle = '#555555';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.arc(0, 0, debris.width/3, 0, Math.PI, true);
                        ctx.stroke();
                    }
                    else if (debris.type === 'antenna') {
                        // Bent antenna
                        ctx.strokeStyle = '#999999';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, -debris.height/2);
                        
                        // Create a bent shape
                        ctx.bezierCurveTo(
                            debris.width/2, -debris.height/4,
                            debris.width/2, debris.height/4,
                            debris.width/2, debris.height/2
                        );
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            } else {
                ctx.save();
                ctx.translate(lander.x, lander.y);
                ctx.rotate(lander.angle);

                // Main body - more capsule shaped
                ctx.fillStyle = '#E0E0E8';
                ctx.beginPath();
                ctx.moveTo(-15, -20);
                ctx.quadraticCurveTo(-18, -20, -18, -15);
                ctx.lineTo(-18, 5);
                ctx.quadraticCurveTo(-18, 10, -15, 10);
                ctx.lineTo(15, 10);
                ctx.quadraticCurveTo(18, 10, 18, 5);
                ctx.lineTo(18, -15);
                ctx.quadraticCurveTo(18, -20, 15, -20);
                ctx.closePath();
                ctx.fill();
                
                // Body gradient
                let bodyGradient = ctx.createLinearGradient(-15, 0, 15, 0);
                bodyGradient.addColorStop(0, "#D0D0D8");
                bodyGradient.addColorStop(0.5, "#F0F0F8");
                bodyGradient.addColorStop(1, "#D0D0D8");
                ctx.fillStyle = bodyGradient;
                ctx.fill();
                
                // Outline
                ctx.strokeStyle = '#999999';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Viewport with reflection effect
                let viewportGradient = ctx.createRadialGradient(2, -12, 1, 0, -10, 8);
                viewportGradient.addColorStop(0, "#FFFFFF");
                viewportGradient.addColorStop(0.3, "#8888FF");
                viewportGradient.addColorStop(1, "#4444AA");
                ctx.fillStyle = viewportGradient;
                ctx.beginPath();
                ctx.arc(0, -10, 7, 0, Math.PI * 2);
                ctx.fill();
                
                // Viewport border
                ctx.strokeStyle = '#666666';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // Decorative details - antenna
                ctx.strokeStyle = '#999999';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.lineTo(0, -28);
                ctx.lineTo(3, -30);
                ctx.stroke();
                
                // Landing gear - more detailed
                ctx.strokeStyle = '#777777';
                ctx.lineWidth = 2;
                
                // Left leg
                ctx.beginPath();
                ctx.moveTo(-12, 8);
                ctx.lineTo(-20, 25);
                ctx.stroke();

                // Right leg
                ctx.beginPath();
                ctx.moveTo(12, 8);
                ctx.lineTo(20, 25);
                ctx.stroke();

                // Small details - side thrusters
                ctx.fillStyle = '#888888';
                ctx.beginPath();
                ctx.rect(-16, -2, 2, 5);
                ctx.rect(14, -2, 2, 5);
                ctx.fill();
                
                // Panel lines
                ctx.strokeStyle = '#AAAAAA';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(-10, -15);
                ctx.lineTo(10, -15);
                ctx.moveTo(-12, 0);
                ctx.lineTo(12, 0);
                ctx.stroke();

                // Draw main thruster flame behind the lander
                if (keys['arrowup'] && fuel > 0 && !lander.controlsDisabled) {
                    // Save current state before drawing flame
                    ctx.save();
                    
                    // Move flame behind the lander by using globalCompositeOperation
                    ctx.globalCompositeOperation = 'destination-over';
                    
                    // Give the flame some variability
                    let flameHeight = 30 + Math.random() * 7; 
                    let flameWidth = 7 + Math.random() * 1;
                    
                    // Position flame higher up (reduce the 10 to a smaller value)
                    let flameStartY = 1; // Start flame higher up behind the vessel
                     
                    // We'll position the gradient roughly in the vertical center of the flame
                    let centerY = flameStartY + flameHeight / 2; 

                    // Create a radial gradient that starts bright in the center and goes to red on the edges
                    let gradient = ctx.createRadialGradient(
                        0, centerY, 0,         // inner circle (x, y, radius)
                        0, centerY, flameWidth * 1.2 // outer circle (x, y, radius)
                    );
                    // A bright core that transitions to yellow, orange, and finally red
                    gradient.addColorStop(0.0, 'white');
                    gradient.addColorStop(0.25, 'yellow');
                    gradient.addColorStop(0.80, 'orange');
                    gradient.addColorStop(1.0, 'orange');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    // Start at the top (behind the lander)
                    ctx.moveTo(0, flameStartY);

                    // Left side curve: top -> mid -> bottom
                    ctx.bezierCurveTo(
                        -flameWidth, flameStartY + flameHeight * 0.3,
                        -flameWidth, flameStartY + flameHeight * 0.7,
                        0,          flameStartY + flameHeight
                    );

                    // Right side curve: bottom -> mid -> top
                    ctx.bezierCurveTo(
                        flameWidth, flameStartY + flameHeight * 0.7,
                        flameWidth, flameStartY + flameHeight * 0.3,
                        0,         flameStartY
                    );
                    ctx.closePath();
                    ctx.fill();
                    
                    // Restore drawing state
                    ctx.restore();
                }

                if (keys['a'] && fuel > 0 && !lander.controlsDisabled) {
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.moveTo(-15, -2.5);
                    ctx.lineTo(-25 - Math.random() * 5, 0);
                    ctx.lineTo(-15, 2.5);
                    ctx.closePath();
                    ctx.fill();
                }

                if (keys['d'] && fuel > 0 && !lander.controlsDisabled) {
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.moveTo(15, -2.5);
                    ctx.lineTo(25 - Math.random() * 5, 0);
                    ctx.lineTo(15, 2.5);
                    ctx.closePath();
                    ctx.fill();
                }

                if (keys['arrowright'] && fuel > 0 && !lander.controlsDisabled) {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(-15, -16.5);
                    ctx.lineTo(-25 - Math.random() * 5, -10);
                    ctx.lineTo(-15, -12.5);
                    ctx.closePath();
                    ctx.fill();
                }

                if (keys['arrowleft'] && fuel > 0 && !lander.controlsDisabled) {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(15, -16.5);
                    ctx.lineTo(25 - Math.random() * 5, -10);
                    ctx.lineTo(15, -12.5);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }

            ctx.restore();

            updateHUD();
        }

        let lastTime = 0;
        let hudUpdateCounter = 0;  // Add counter for throttling HUD updates
        let hudUpdateFrequency = 5;  // Only update every 5 frames
        let lastHeightDisplay = 0;
        let lastVelocityDisplay = 0;
        let lastHorizontalVelocityDisplay = 0; // Add variable for horizontal velocity

        function updateHUD() {
            const groundY = getTerrainHeightAt(lander.x);
            const heightAboveTerrain = groundY - (lander.y + 20);

            const fuelPercentage = Math.max(0, Math.min((fuel / 1900) * 100, 100));
            document.getElementById('mini-fuel-value').textContent = Math.floor(fuelPercentage) + '%';
            const miniFuelBar = document.getElementById('mini-fuel-bar');
            miniFuelBar.style.width = fuelPercentage + '%';

            const oxygenPercentage = Math.max(0, Math.min((oxygen / 70) * 100, 100));
            document.getElementById('mini-oxygen-value').textContent = Math.floor(oxygenPercentage) + '%';
            const miniOxygenBar = document.getElementById('mini-oxygen-bar');
            miniOxygenBar.style.width = oxygenPercentage + '%';

            if (oxygen > 10) {
                miniOxygenBar.style.backgroundColor = "#009dff";
            } else if (oxygen > 5) {
                miniOxygenBar.style.backgroundColor = 'orange';
            } else {
                miniOxygenBar.style.backgroundColor = 'red';
            }

            if (fuelPercentage > 50) {
                miniFuelBar.style.backgroundColor = '#00c400';
            } else if (fuelPercentage > 20) {
                miniFuelBar.style.backgroundColor = 'yellow';
            } else {
                miniFuelBar.style.backgroundColor = 'red';
            }

            document.getElementById('scoreValue').textContent = score;
            document.getElementById('highScoreValue').textContent = highScore;
            
            // Throttle height and velocity updates to reduce flickering
            hudUpdateCounter++;
            if (hudUpdateCounter >= hudUpdateFrequency) {
                hudUpdateCounter = 0;
                
                // Update vertical velocity (absolute value, no decimals)
                const absoluteVelocity = Math.floor(Math.abs(lander.vy));
                lastVelocityDisplay = absoluteVelocity;
                document.getElementById('verticalVelocityValue').textContent = absoluteVelocity;
                
                // Update horizontal velocity (absolute value, no decimals)
                const absoluteHorizontalVelocity = Math.floor(Math.abs(lander.vx));
                lastHorizontalVelocityDisplay = absoluteHorizontalVelocity;
                document.getElementById('horizontalVelocityValue').textContent = absoluteHorizontalVelocity;
                
                // Update height (divided by 10, with "m" suffix)
                const heightInMeters = Math.floor(heightAboveTerrain / 10);
                lastHeightDisplay = heightInMeters;
                document.getElementById('heightValue').textContent = heightInMeters + "m";
            } else {
                // Use last calculated values to maintain display
                document.getElementById('verticalVelocityValue').textContent = lastVelocityDisplay;
                document.getElementById('horizontalVelocityValue').textContent = lastHorizontalVelocityDisplay;
                document.getElementById('heightValue').textContent = lastHeightDisplay + "m";
            }
        }

        function crash() {
            lander.crashed = true;
            lander.landed = false;
            lander.crashTime = Date.now(); // Track when crash occurred
            lander.gameOverShown = false;  // Flag for showing game over message

            // Stop sounds
            if (mainEngineSoundPlaying) {
                mainEngineSound.pause();
                mainEngineSound.currentTime = 0;
                mainEngineSoundPlaying = false;
            }
            if (rotationEngineSoundPlaying || translationEngineSoundPlaying) {
                rotationEngineSound.pause();
                rotationEngineSound.currentTime = 0;
                rotationEngineSoundPlaying = false;
                translationEngineSoundPlaying = false;
            }
            if (breathingSoundPlaying) {
                breathingSound.pause();
                breathingSound.currentTime = 0;
                breathingSoundPlaying = false;
            }
            if (riserSoundPlaying) {
                riserSound.pause();
                riserSound.currentTime = 0;
                riserSoundPlaying = false;
            }

            crashSound.play();
            
            // Calculate impact information for more realistic debris
            const impactVelocity = Math.sqrt(lander.vx * lander.vx + lander.vy * lander.vy);
            const impactEnergy = 0.5 * lander.mass * impactVelocity * impactVelocity;
            
            // Check if this is a horizontal impact (hitting a cliff face)
            const groundY = getTerrainHeightAt(lander.x);
            const isCliffImpact = Math.abs(lander.vx) > Math.abs(lander.vy) && 
                                  lander.y + 20 < groundY - 10;
                                  
            // Calculate impact direction and strength
            const impactAngle = Math.atan2(lander.vy, lander.vx);
            const horizontalImpact = Math.abs(lander.vx) / (Math.abs(lander.vx) + Math.abs(lander.vy) + 0.1);
            
            // Create explosion particles (existing code with enhancements)
            lander.explosionParticles = [];
            let numParticles = Math.min(50, 30 + Math.floor(impactVelocity / 10));
            for (let i = 0; i < numParticles; i++) {
                // More particles in direction of travel for high-speed impacts
                const particleAngle = isCliffImpact ? 
                    Math.PI - impactAngle + (Math.random() - 0.5) * Math.PI * 0.7 : // Reflect off cliff
                    impactAngle + (Math.random() - 0.5) * Math.PI;
                
                const speedMultiplier = 1 + (impactVelocity / 100);
                
                lander.explosionParticles.push({
                    x: lander.x + (Math.random() - 0.5) * 15,
                    y: lander.y + (Math.random() - 0.5) * 15,
                    vx: Math.cos(particleAngle) * (150 + Math.random() * 100) * speedMultiplier,
                    vy: Math.sin(particleAngle) * (150 + Math.random() * 100) * speedMultiplier,
                    alpha: 1.0 + Math.random() * 0.5, // Longer-lasting particles
                    size: 3 + Math.random() * 4 * speedMultiplier,
                });
            }
            
            // Create debris particles representing parts of the lander
            lander.debrisParticles = [];
            
            // Calculate base velocity components from lander's velocity
            const baseVelX = lander.vx;
            const baseVelY = lander.vy;
            const impactMagnitude = Math.sqrt(baseVelX * baseVelX + baseVelY * baseVelY);
            
            // Direction adjustment for cliff impacts - debris should rebound
            let directionModifier = isCliffImpact ? -1 : 1;
            
            // Main hull fragments - more fragments for higher impact energy
            const numHullPieces = Math.min(7, 3 + Math.floor(impactVelocity / 20));
            for (let i = 0; i < numHullPieces; i++) {
                const size = 6 + Math.random() * 12;
                
                // Vary the angle more with higher speed impacts
                const angleVariance = Math.PI * 0.4 * (1 + impactVelocity / 100);
                const spreadAngle = impactAngle + (Math.random() - 0.5) * angleVariance;
                
                // Add more speed variation for higher impacts
                const speedVariance = 0.4 + Math.random() * 0.8 * (1 + impactVelocity / 100);
                const speed = impactMagnitude * speedVariance;
                
                // Create jagged edges for the hull pieces
                const jaggedness = [
                    Math.random() * 4,
                    Math.random() * 4,
                    Math.random() * 4,
                    Math.random() * 4
                ];
                
                lander.debrisParticles.push({
                    x: lander.x + (Math.random() - 0.5) * 15,
                    y: lander.y + (Math.random() - 0.5) * 15,
                    vx: directionModifier * Math.cos(spreadAngle) * speed * (isCliffImpact ? 1.5 : 1),
                    vy: Math.sin(spreadAngle) * speed * (isCliffImpact ? 0.8 : 1),
                    width: size,
                    height: size * (0.7 + Math.random() * 0.6),
                    angle: Math.random() * Math.PI * 2,
                    angularVelocity: (Math.random() - 0.5) * 15 * (1 + impactVelocity / 50),
                    type: 'hull',
                    jaggedness: jaggedness
                });
            }
            
            // Viewport (glass) - potentially multiple pieces for high impacts
            const viewportPieces = impactVelocity > 80 ? 2 : 1;
            for (let i = 0; i < viewportPieces; i++) {
                const viewportSpreadAngle = impactAngle + (Math.random() - 0.5) * Math.PI * 0.8;
                const viewportSpeed = impactMagnitude * (0.6 + Math.random() * 0.7);
                
                lander.debrisParticles.push({
                    x: lander.x + (Math.random() - 0.5) * 10,
                    y: lander.y - 10 + (Math.random() - 0.5) * 5,
                    vx: directionModifier * Math.cos(viewportSpreadAngle) * viewportSpeed,
                    vy: Math.sin(viewportSpreadAngle) * viewportSpeed - Math.random() * 30,
                    width: 7 + Math.random() * 3,
                    height: 7 + Math.random() * 3,
                    angle: Math.random() * Math.PI * 2,
                    angularVelocity: (Math.random() - 0.5) * 8,
                    type: 'viewport'
                });
            }
            
            // Landing legs
            for (let i = 0; i < 2; i++) {
                const direction = i === 0 ? -1 : 1; // Left or right leg
                const legSpreadAngle = impactAngle + direction * (Math.PI/4 + Math.random() * Math.PI/3);
                const legSpeed = impactMagnitude * (0.6 + Math.random() * 0.7);
                
                lander.debrisParticles.push({
                    x: lander.x + direction * 15,
                    y: lander.y + 15 + Math.random() * 5,
                    vx: Math.cos(legSpreadAngle) * legSpeed + direction * (20 + Math.random() * 10),
                    vy: Math.sin(legSpreadAngle) * legSpeed - Math.random() * 30,
                    width: 4 + Math.random() * 2,
                    height: 15 + Math.random() * 10,
                    angle: Math.random() * Math.PI * 2,
                    angularVelocity: direction * (5 + Math.random() * 10),
                    type: 'leg'
                });
            }
            
            // Thrusters - with heat discoloration
            for (let i = 0; i < 2; i++) {
                const direction = i === 0 ? -1 : 1; // Left or right thruster
                const thrusterSpreadAngle = impactAngle + direction * (Math.PI/3 + Math.random() * Math.PI/4);
                const thrusterSpeed = impactMagnitude * (0.7 + Math.random() * 0.6);
                
                lander.debrisParticles.push({
                    x: lander.x + direction * 15,
                    y: lander.y + (Math.random() - 0.5) * 8,
                    vx: Math.cos(thrusterSpreadAngle) * thrusterSpeed + direction * (15 + Math.random() * 10),
                    vy: Math.sin(thrusterSpreadAngle) * thrusterSpeed - Math.random() * 20,
                    width: 5 + Math.random() * 3,
                    height: 7 + Math.random() * 3,
                    angle: Math.random() * Math.PI * 2,
                    angularVelocity: (Math.random() - 0.5) * 12,
                    type: 'thruster'
                });
            }
            
            // Antenna
            lander.debrisParticles.push({
                x: lander.x + (Math.random() - 0.5) * 5,
                y: lander.y - 25 + (Math.random() - 0.5) * 5,
                vx: baseVelX * 0.3 + (Math.random() - 0.5) * 40,
                vy: baseVelY * 0.2 - 50 - Math.random() * 30,
                width: 5,
                height: 12,
                angle: Math.random() * Math.PI * 2,
                angularVelocity: (Math.random() - 0.5) * 15,
                type: 'antenna'
            });
            
            // Create an impact crater based on the crash energy
            const craterSize = Math.min(40, 20 + impactEnergy / 10000);
            craterMarks.push({
                x: lander.x,
                y: groundY,
                radius: craterSize,
                fresh: true,  // Mark as a fresh crater for special rendering if desired
                // Store depth information if you want to modify how craters are rendered
                depth: Math.min(10, 5 + impactEnergy / 20000)
            });
        }

        function successfulLanding(platform) {
            if (!platform.landed) {
                score += platform.points;
                fuel += 340;
                oxygen += 17.5;
                fuel = Math.min(fuel, 1900);
                oxygen = Math.min(oxygen, 70);
                
                // Optimize sound playback for minimal delay
                try {
                    fuelUpSound.pause(); // Stop any existing playback
                    fuelUpSound.currentTime = 0; // Reset to beginning
                    const playPromise = fuelUpSound.play();
                    
                    // Handle promise in case of autoplay restrictions
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.log("Could not play fuel up sound:", error);
                        });
                    }
                } catch (e) {
                    console.log("Error playing fuel up sound:", e);
                }
            }
            lander.vx = 0;
            lander.vy = 0;
            lander.angularVelocity = 0;
            lander.angle = 0;

            lander.landed = true;

            score += 50;
        }

        function endGame(message) {
            gameOver = true;

            // Fade down background music to 25% over 3 seconds
            if (backgroundSound.volume > 0) {
            fadeAudioVolume(backgroundSound, backgroundSound.volume, 0.125, 1500);
            }
            
            // Play game over sound
            if (!gameOverSoundPlaying) {
            gameOverSound.currentTime = 0;
            gameOverSound.play().catch(err => console.log("Could not play game over sound:", err));
            gameOverSoundPlaying = true;
            }

            // Stop all other active sounds
            if (mainEngineSoundPlaying) {
            mainEngineSound.pause();
            mainEngineSound.currentTime = 0;
            mainEngineSoundPlaying = false;
            }
            if (rotationEngineSoundPlaying || translationEngineSoundPlaying) {
            rotationEngineSound.pause();
            rotationEngineSound.currentTime = 0;
            rotationEngineSoundPlaying = false;
            translationEngineSoundPlaying = false;
            }
            if (breathingSoundPlaying) {
            breathingSound.pause();
            breathingSound.currentTime = 0;
            breathingSoundPlaying = false;
            }
            if (riserSoundPlaying) {
            riserSound.pause();
            riserSound.currentTime = 0;
            riserSoundPlaying = false;
            }

            // Update high score if needed
            if (score > highScore) {
            highScore = score;
            localStorage.setItem('moonLanderHighScore', highScore);
            document.getElementById('highScoreValue').textContent = highScore;
            }

            // Get random message from gameOverMessages array
            const randomMessage = gameOverMessages[Math.floor(Math.random() * gameOverMessages.length)];
            
            // Display game over message
            const messageDiv = document.getElementById('message');
            const gameMessage = document.getElementById('gameMessage');
            
            // Create and add pulsing shadow animation
            const style = document.createElement('style');
            style.textContent = `
            @keyframes pulseShadow {
                0% { box-shadow: 0 0 30px rgba(255, 0, 0, 0.3), 0 0 60px rgba(255, 0, 0, 0.2); }
                50% { box-shadow: 0 0 40px rgba(255, 0, 0, 0.3), 0 0 80px rgba(255, 0, 0, 0.3); }
                100% { box-shadow: 0 0 30px rgba(255, 0, 0, 0.3), 0 0 60px rgba(255, 0, 0, 0.2); }
            }
            `;
            document.head.appendChild(style);
            
            // Apply enhanced styling to message box with animation
            messageDiv.style.background = 'rgba(0, 0, 0, 0.85)';
            messageDiv.style.borderRadius = '15px';
            messageDiv.style.animation = 'pulseShadow 4s ease-in-out infinite';
            messageDiv.style.border = '1px solid rgba(255, 100, 100, 0.5)';
            messageDiv.style.padding = '40px';
            messageDiv.style.maxWidth = '500px';
            
            // Set message content
            gameMessage.innerHTML = `<div style="font-size: 32px; margin-bottom: 20px; color: #ff7777;">MISSION FAILED</div>
                        <div style="font-size: 20px; margin-bottom: 30px;">${randomMessage}</div>
                        <div style="color: #aaaaaa; margin-top: 20px;">Final Score: ${score}</div>`;
            
            messageDiv.style.display = 'block';
        }

        function restartGame() {
            oxygen = 60;
            fuel = 1900;
            score = 0;
            gameOver = false;
            lander.crashed = false;
            lander.landed = false;
            lander.controlsDisabled = false;
            generateLandscape();
            generateStars();
            meteorites = [];
            craterMarks = [];
            rocks = [];
            dustParticles = [];
            document.getElementById('message').style.display = 'none';
            lander.vx = 0;
            lander.vy = 0;
            lander.angle = 0;
            lander.angularVelocity = 0;
            lander.explosionParticles = [];
            lander.currentPlatform = null;

            mainEngineSound.pause();
            mainEngineSound.currentTime = 0;
            mainEngineSoundPlaying = false;
            
            mainThrusterStartTime = null;
            if (mainThrusterReleaseTimer !== null) {
                clearTimeout(mainThrusterReleaseTimer);
                mainThrusterReleaseTimer = null;
            }

            rotationEngineSoundPlaying = false;
            rotationEngineSound.pause();
            rotationEngineSound.currentTime = 0;

            crashSound.pause();
            crashSound.currentTime = 0;

            breathingSound.pause();
            breathingSound.currentTime = 0;
            breathingSoundPlaying = false;

            translationEngineSoundPlaying = false;

            if (riserSoundPlaying) {
                riserSound.pause();
                riserSound.currentTime = 0;
                riserSoundPlaying = false;
            }

            // Stop game over sound if playing
            if (gameOverSoundPlaying) {
                gameOverSound.pause();
                gameOverSound.currentTime = 0;
                gameOverSoundPlaying = false;
            }
            
            // Reset background music volume and restart it with fade in
            backgroundSound.volume = 0.1; // Start at low volume
            playBackgroundMusic();
            fadeAudioVolume(backgroundSound, 0.1, 0.5, 250); // Fade from 0.1 to 0.5 over 250ms
            
            // Play vessel startup sound
            vesselStartupSound.currentTime = 0;
            vesselStartupSound.play().catch(err => console.log("Could not play vessel startup sound:", err));
        }

        function emitDustParticles(deltaTimeSec) {
            const groundY = getTerrainHeightAt(lander.x);
            const heightAboveTerrain = groundY - (lander.y + 20);

            const emissionThreshold = 100;
            if (heightAboveTerrain > emissionThreshold) return;

            const proximity = Math.max(0, emissionThreshold - heightAboveTerrain);
            const emissionRate = proximity / emissionThreshold;

            const maxParticlesPerFrame = 5;
            const particlesToEmit = Math.floor(emissionRate * maxParticlesPerFrame);

            for (let i = 0; i < particlesToEmit; i++) {
                const offsetX = (Math.random() - 0.5) * 20;
                const dustX = lander.x + offsetX;
                const dustY = groundY;

                const angle = (Math.random() * Math.PI / 2) + Math.PI / 4;
                const speed = Math.random() * 50 + 50;
                const vx = speed * Math.cos(angle) * (Math.random() < 0.5 ? -1 : 2);
                const vy = speed * Math.sin(angle) * -1;

                dustParticles.push({
                    x: dustX,
                    y: dustY,
                    vx: vx,
                    vy: vy,
                    size: Math.random() * 2 + 1,
                    alpha: 1.0,
                    lifespan: 1.0,
                });
            }
        }

        function updateDustParticles(deltaTimeSec) {
            for (let dust of dustParticles) {
                dust.x += dust.vx * deltaTimeSec;
                dust.y += dust.vy * deltaTimeSec;
                dust.vy += gravity * deltaTimeSec * 0.2;
                dust.lifespan -= deltaTimeSec;
                dust.alpha = Math.max(dust.lifespan / 1.0, 0);
            }
            dustParticles = dustParticles.filter(dust => dust.alpha > 0 && dust.x > cameraX - 50 && dust.x < cameraX + width + 50 && dust.y > cameraY - 50 && dust.y < cameraY + height + 50);
        }

        function updateMeteorites(deltaTimeSec) {
            if (Math.random() < 0.0001) {
                let fromLeft = Math.random() < 0.5;
                let x = fromLeft ? cameraX - 200 : cameraX + width + 200;
                let y = cameraY - 100;
                let angle = fromLeft ? Math.PI / 4 : (3 * Math.PI) / 4;
                let speed = 200 + Math.random() * 100;

                meteorites.push({
                    x,
                    y,
                    vx: speed * Math.cos(angle),
                    vy: speed * Math.sin(angle),
                    exploded: false,
                });
            }

            for (let meteor of meteorites) {
                if (!meteor.exploded) {
                    meteor.x += meteor.vx * deltaTimeSec;
                    meteor.y += meteor.vy * deltaTimeSec;
                    meteor.vy += gravity * deltaTimeSec;

                    let groundY = getTerrainHeightAt(meteor.x);
                    if (meteor.y >= groundY) {
                        meteor.exploded = true;
                        meteor.explosionParticles = [];
                        let numParticles = 15;
                        for (let i = 0; i < numParticles; i++) {
                            meteor.explosionParticles.push({
                                x: meteor.x,
                                y: groundY,
                                vx: (Math.random() - 0.5) * 100,
                                vy: (Math.random() - 0.5) * 100,
                                alpha: 1.0,
                            });
                        }
                        craterMarks.push({
                            x: meteor.x,
                            y: groundY,
                            radius: 20 + Math.random() * 10,
                        });
                    }

                    let dx = meteor.x - lander.x;
                    let dy = meteor.y - lander.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 20 && !lander.crashed) {
                        meteor.exploded = true;
                        crash();
                        meteorites.splice(meteorites.indexOf(meteor), 1);
                        continue;
                    }

                } else {
                    for (let particle of meteor.explosionParticles) {
                        particle.x += particle.vx * deltaTimeSec;
                        particle.y += particle.vy * deltaTimeSec;
                        particle.vy += gravity * deltaTimeSec;
                        particle.alpha -= deltaTimeSec * 0.5;
                    }
                    meteor.explosionParticles = meteor.explosionParticles.filter(p => p.alpha > 0);
                }
            }
            meteorites = meteorites.filter(meteor => !meteor.exploded || meteor.explosionParticles.length > 0);
        }

        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            let deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        function showControlsInstructions() {
            const controlsGuide = document.createElement('div');
            controlsGuide.id = 'controlsGuide';
            
            let controlsHTML = `
                <h3 style="text-align: center; margin-top: 0;">CONTROLS</h3>
            `;
            
            // Show different control instructions based on device
            if (isMobile) {
                controlsHTML += `
                    <div style="text-align: center; margin-bottom: 15px;">
                        Use the touch controls at the bottom of the screen:
                    </div>
                    <div class="control-row">
                        <div class="control-description">▲ - Main Thruster</div>
                    </div>
                    <div class="control-row">
                        <div class="control-description">↺/↻ - Rotate Lander</div>
                    </div>
                    <div class="control-row">
                        <div class="control-description">◀/▶ - Side Thrusters</div>
                    </div>
                `;
            } else {
                controlsHTML += `
                    <div class="control-row">
                        <div class="key">↑</div>
                        <div class="control-description">Main Thruster</div>
                    </div>
                    <div class="control-row">
                        <div class="key">←</div>
                        <div class="key">→</div>
                        <div class="control-description">Rotate Lander</div>
                    </div>
                    <div class="control-row">
                        <div class="key">A</div>
                        <div class="key">D</div>
                        <div class="control-description">Translation Thrusters (Side Movement)</div>
                    </div>
                `;
            }
            
            controlsGuide.innerHTML = controlsHTML;
            
            const startButton = document.getElementById('startButton');
            loadingScreen.insertBefore(controlsGuide, startButton);
        }
    </script>
</body>
</html>